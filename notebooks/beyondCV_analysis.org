#+TITLE: Beyond Cosmic Variance Analysis

* Preamble
#+BEGIN_SRC ipython :session bcv :results none
  %matplotlib inline
  import matplotlib.pyplot as plt
  # plt.rcParams["text.usetex"] = True
  import pandas as pd
  import numpy as np
  from getdist import plots, MCSamples
  from IPython.display import HTML, display
  import tabulate
  import glob
#+END_SRC

* Plot cosmological parameters distribution
** Cosmo. parameters LaTeX labels
#+BEGIN_SRC ipython :session bcv :results none
  labels = [r"$\theta_\mathrm{MC}$",
            r"$A_\mathrm{s}$",
            r"$n_\mathrm{s}$",
            r"$\Omega_\mathrm{b}h^2$",
            r"$\Omega_\mathrm{c}h^2$",
            r"$\chi^2-\chi^2_\mathrm{min}$"]
#+END_SRC

** Get cosmo. parameters from output file
#+BEGIN_SRC ipython :session bcv :results none
  def get_params(path, pattern="*.likelihood", weight=False):
      import os, glob
      all_files = glob.glob(os.path.join(path, pattern))
      # Sort alphabetically
      all_files.sort()

      header = pd.read_csv(all_files[0], delim_whitespace=True).columns[1:]
      df = pd.concat((pd.read_table(f, delim_whitespace=True) for f in all_files))

      # Remove '#' in header
      df.drop(df.columns[[-1,]], axis=1, inplace=True)
      df.columns = header
      # Compute delta chi2
      delta_chi2 = df.chi2-np.min(df.chi2)
      # Remove useless columns
      df.drop(columns=["weight", "minuslogpost", "minuslogprior", "minuslogprior__0", "chi2", "chi2__chi2"], inplace=True)
      # Insert Delta chi2 before As (which is derived and never plot)
      df.insert(value=delta_chi2, column="delta_chi2", loc=len(df.columns))

      return np.array(df)
#+END_SRC

** Show input values of cosmo. parameters
#+BEGIN_SRC ipython :session bcv :results none
  def show_ref(g):
      ref = [1.04164/100, np.exp(3.058)/1e10, 0.9649, 0.02212, 0.1210]
      for i, r in enumerate(ref):
          kwargs = dict(color="gray", ls="--", lw=1)
          for ax in g.subplots[:,i]:
              if ax: ax.axvline(r, **kwargs)
          for ax in g.subplots[i,:i]:
              if ax: ax.axhline(r, **kwargs)
#+END_SRC
** Results from pure Planck simulation
*** Cosmo. parameters distribution
#+BEGIN_SRC ipython :session bcv :results none
  params = get_params(r"/home/garrido/Workdir/CMB/analysis/beyondCV/output/unbinned")
  samples = MCSamples(samples=params, names=labels)
#+END_SRC

#+BEGIN_SRC ipython :session bcv :results raw drawer
  g = plots.getSubplotPlotter()
  g.settings.colormap = "inferno"
  g.triangle_plot(samples, params=labels[:-1], shaded=True)
  show_ref(g)
#+END_SRC

#+RESULTS:
:results:
# Out[1100]:
[[file:./obipy-resources/Qnku27.png]]
:end:

#+BEGIN_SRC ipython :session bcv :results raw drawer
  g = plots.getSubplotPlotter()
  g.settings.colormap_scatter = "inferno"
  g.triangle_plot(samples, params=labels[:-1],
                  plot_3d_with_param="$\chi^2-\chi^2_\mathrm{min}$", scatter_size=20)
  show_ref(g)
#+END_SRC

#+RESULTS:
:results:
# Out[1101]:
[[file:./obipy-resources/O10Mbg.png]]
:end:

#+BEGIN_SRC ipython :session bcv :results output
  print("Number of sucessful minimization :", np.alen(params))
#+END_SRC

#+RESULTS:
: Number of sucessful minimization : 638

#+BEGIN_SRC ipython :session bcv :results none
  min_mean = np.mean(params, axis=0)
  min_std  = np.std(params, axis=0)
  fisher = np.array([5.1265507267143515e-06, 1.2854648947626772e-11, 0.005589724100405197, 0.00020382255228959767, 0.002334040314343261, 1.])
  lines = [[r"$\mu$"], [r"$\sigma$"], [r"$\sigma$ (Fisher)"], [r"$\Delta\sigma$ (min-Fisher) [%]"]]
  table = np.stack([min_mean, min_std, fisher, 100*(min_std-fisher)/fisher])
  table = np.append(lines, table, axis=1)
#+END_SRC

#+BEGIN_SRC ipython :session bcv :results raw drawer
  display(HTML(tabulate.tabulate(table, headers=labels, tablefmt="html")))
#+END_SRC

#+RESULTS:
:results:
# Out[17]:
: <IPython.core.display.HTML object>
:end:

*** Org table                                                    :noexport:

#+BEGIN_SRC ipython :session bcv :results raw output :export none
  print(tabulate.tabulate(table, headers=labels, tablefmt="orgtbl"))
#+END_SRC

#+RESULTS:
|                                 | $\theta_\mathrm{MC}$ | $A_\mathrm{s}$ | $n_\mathrm{s}$ | $\Omega_\mathrm{b}h^2$ | $\Omega_\mathrm{c}h^2$ | $\chi^2-\chi^2_\mathrm{min}$ |
|---------------------------------+----------------------+----------------+----------------+------------------------+------------------------+------------------------------|
| $\mu$                           |            0.0104162 |    2.12887e-09 |       0.964695 |              0.0221223 |                0.12108 |                      460.202 |
| $\sigma$                        |          4.99937e-06 |    1.24047e-11 |     0.00544548 |            0.000206822 |              0.0022281 |                      153.421 |
| $\sigma$ (Fisher)               |          5.12655e-06 |    1.28546e-11 |     0.00558972 |            0.000203823 |             0.00233404 |                            1 |
| $\Delta\sigma$ (min-Fisher) [%] |             -2.48081 |        -3.5002 |       -2.58047 |                1.47141 |                -4.5391 |                      15242.1 |

* Simons Observatory ⊗ Planck
** \ell \in [2; 3000]
#+BEGIN_SRC ipython :session bcv :results raw drawer
  params_SO   = get_params(r"/home/garrido/Workdir/CMB/analysis/beyondCV/output/ell_2_3000", "*SO.likelihood")
  params_SOxP = get_params(r"/home/garrido/Workdir/CMB/analysis/beyondCV/output/ell_2_3000", "*SOxP.likelihood")
  params_P    = get_params(r"/home/garrido/Workdir/CMB/analysis/beyondCV/output/ell_2_3000", "*_P.likelihood")
  params_SO.shape, params_SOxP.shape, params_P.shape
#+END_SRC

#+RESULTS:
:results:
# Out[1085]:
: ((978, 6), (978, 6), (978, 6))
:end:
*** Triangle plot
#+BEGIN_SRC ipython :session bcv :results none
  samples_SO   = MCSamples(samples=params_SO, names=labels, label="SOxSO")
  samples_SOxP = MCSamples(samples=params_SOxP, names=labels, label="SOxP")
  samples_P    = MCSamples(samples=params_P, names=labels, label="PxP")
#+END_SRC

#+BEGIN_SRC ipython :session bcv :results raw drawer
  g = plots.getSubplotPlotter()
  g.triangle_plot([samples_SO, samples_SOxP, samples_P], params=labels[:-1])
  show_ref(g)
#+END_SRC

#+RESULTS:
:results:
# Out[1092]:
[[file:./obipy-resources/xEOpts.png]]
:end:

*** Variances of parameters
#+BEGIN_SRC ipython :session bcv :results none
  lines = [[r"$\mu$(SOxSO)"], [r"$\mu$(SOxP)"], [r"$\mu$(PxP)"],
           [r"$\sigma$(SOxSO)"], [r"$\sigma$(SOxP)"], [r"$\sigma$(PxP)"],
           [r"$\sigma$(SOxSO - PxP)"], [r"$\sigma$(SOxSO - SOxP)"], [r"$\sigma$(SOxSO + PxP - 2 SOxP)"]]
  std_SO, std_SOxP, std_P = np.std(params_SO, axis=0), np.std(params_SOxP, axis=0), np.std(params_P, axis=0)
  std_SOmP = np.std(params_SO-params_P, axis=0)
  std_SOmSOxP = np.std(params_SO-params_SOxP, axis=0)
  std_SOpPm2SOxP = np.std(params_SO + params_P - 2*params_SOxP, axis=0)
  table = np.stack([np.mean(params_SO, axis=0),
                    np.mean(params_SOxP, axis=0),
                    np.mean(params_P, axis=0),
                    std_SO, std_SOxP, std_P,
                    std_SOmP, std_SOmSOxP, std_SOpPm2SOxP
  ])
  table = np.append(lines, table, axis=1)
  display(HTML(tabulate.tabulate(table, headers=labels, tablefmt="html")))
#+END_SRC

Set PxP deviation as standard for further comparison
#+BEGIN_SRC ipython :session bcv :results none
  ref_std = std_P
  print(ref_std)
#+END_SRC

#+BEGIN_SRC ipython :session bcv :results raw drawer
  x = np.arange(5)
  plt.plot(x, (ref_std/std_SO)[:-1], "o", label="SOxSO")
  plt.plot(x, (ref_std/std_SOxP)[:-1], "o", label="SOxP")
  plt.plot(x, (ref_std/std_SOmP)[:-1], "o", label="SOxSO-PxP")
  plt.plot(x, (ref_std/std_SOmSOxP)[:-1], "o", label="SOxSO-SOxP")
  plt.plot(x, (ref_std/std_SOpPm2SOxP)[:-1], "o", label="SOxSO+PxP-2SOxP")
  plt.xticks(x, labels[:-1])
  plt.ylabel(r"$\Delta_\sigma$ (/Planck)")
  plt.legend(loc="upper left", title=r"$\ell\in[2; 3000]$", bbox_to_anchor=(1,1))
#+END_SRC

#+RESULTS:
:results:
# Out[1098]:
: <matplotlib.legend.Legend at 0x7fcbe6e15cf8>
[[file:./obipy-resources/byLexB.png]]
:end:

**** Org table                                                  :noexport:
#+BEGIN_SRC ipython :session bcv :results raw output
  print(tabulate.tabulate(table, headers=labels, tablefmt="orgtbl"))
#+END_SRC


#+TBLNAME: min_l_2_3000
#+RESULTS:
|                                | $\theta_\mathrm{MC}$ | $A_\mathrm{s}$ | $n_\mathrm{s}$ | $\Omega_\mathrm{b}h^2$ | $\Omega_\mathrm{c}h^2$ | $\chi^2-\chi^2_\mathrm{min}$ |
|--------------------------------+----------------------+----------------+----------------+------------------------+------------------------+------------------------------|
| $\mu$(SOxSO)                   |            0.0104163 |     2.1288e-09 |       0.964831 |              0.0221165 |               0.121037 |                      491.874 |
| $\mu$(SOxP)                    |            0.0104162 |    2.12874e-09 |       0.964837 |              0.0221241 |               0.121029 |                      482.606 |
| $\mu$(PxP)                     |            0.0104161 |    2.12891e-09 |       0.964766 |              0.0221283 |               0.121065 |                      395.489 |
| $\sigma$(SOxSO)                |          3.30158e-06 |    8.82142e-12 |     0.00403527 |            0.000113061 |             0.00147556 |                      155.132 |
| $\sigma$(SOxP)                 |          4.13856e-06 |    1.10042e-11 |      0.0048009 |            0.000153239 |             0.00196259 |                      155.961 |
| $\sigma$(PxP)                  |          4.88563e-06 |    1.22407e-11 |     0.00529792 |            0.000204028 |              0.0022389 |                      149.562 |
| $\sigma$(SOxSO - PxP)          |          3.76192e-06 |    9.58206e-12 |     0.00406034 |            0.000171957 |             0.00181588 |                      148.291 |
| $\sigma$(SOxSO - SOxP)         |          2.53148e-06 |    7.13821e-12 |     0.00291831 |            0.000104709 |             0.00135525 |                      125.786 |
| $\sigma$(SOxSO + PxP - 2 SOxP) |          3.28542e-06 |    9.16644e-12 |     0.00375188 |            0.000160698 |             0.00174672 |                      209.039 |

** \ell \in [50; 2000]
#+BEGIN_SRC ipython :session bcv :results raw drawer
  params_SO   = get_params(r"/home/garrido/Workdir/CMB/analysis/beyondCV/output/ell_50_2000", "*SO.likelihood")
  params_SOxP = get_params(r"/home/garrido/Workdir/CMB/analysis/beyondCV/output/ell_50_2000", "*SOxP.likelihood")
  params_P    = get_params(r"/home/garrido/Workdir/CMB/analysis/beyondCV/output/ell_50_2000", "*_P.likelihood")
  params_SO.shape, params_SOxP.shape, params_P.shape
#+END_SRC

#+RESULTS:
:results:
# Out[3]:
: ((971, 6), (971, 6), (971, 6))
:end:
*** Triangle plot
#+BEGIN_SRC ipython :session bcv :results none
  samples_SO   = MCSamples(samples=params_SO, names=labels, label="SOxSO")
  samples_SOxP = MCSamples(samples=params_SOxP, names=labels, label="SOxP")
  samples_P    = MCSamples(samples=params_P, names=labels, label="PxP")
#+END_SRC

#+BEGIN_SRC ipython :session bcv :results raw drawer
  g = plots.getSubplotPlotter()
  g.triangle_plot([samples_SO, samples_SOxP, samples_P], params=labels[:-1])
  show_ref(g)
#+END_SRC

#+RESULTS:
:results:
# Out[881]:
[[file:./obipy-resources/ARl6ns.png]]
:end:

*** Variances of parameters
#+BEGIN_SRC ipython :session bcv :results none
  lines = [[r"$\mu$(SOxSO)"], [r"$\mu$(SOxP)"], [r"$\mu$(PxP)"],
           [r"$\sigma$(SOxSO)"], [r"$\sigma$(SOxP)"], [r"$\sigma$(PxP)"],
           [r"$\sigma$(SOxSO - PxP)"], [r"$\sigma$(SOxSO - SOxP)"], [r"$\sigma$(SOxSO + PxP - 2 SOxP)"]]
  std_SO, std_SOxP, std_P = np.std(params_SO, axis=0), np.std(params_SOxP, axis=0), np.std(params_P, axis=0)
  std_SOmP = np.std(params_SO-params_P, axis=0)
  std_SOmSOxP = np.std(params_SO-params_SOxP, axis=0)
  std_SOpPm2SOxP = np.std(params_SO + params_P - 2*params_SOxP, axis=0)
  table = np.stack([np.mean(params_SO, axis=0),
                    np.mean(params_SOxP, axis=0),
                    np.mean(params_P, axis=0),
                    std_SO, std_SOxP, std_P,
                    std_SOmP, std_SOmSOxP, std_SOpPm2SOxP
  ])
  table = np.append(lines, table, axis=1)
  display(HTML(tabulate.tabulate(table, headers=labels, tablefmt="html")))
#+END_SRC

#+BEGIN_SRC ipython :session bcv :results raw drawer
  x = np.arange(5)
  plt.plot(x, (ref_std/std_SO-1)[:-1], "o", label="SO")
  plt.plot(x, (ref_std/std_SOxP-1)[:-1], "o", label="SOxP")
  plt.plot(x, (ref_std/std_SOmP-1)[:-1], "o", label="SO-P")
  plt.plot(x, (ref_std/std_SOmSOxP-1)[:-1], "o", label="SO-SOxP")
  plt.plot(x, (ref_std/std_SOpPm2SOxP-1)[:-1], "o", label="SO+P-2SOxP")
  plt.xticks(x, labels[:-1])
  plt.ylabel(r"$\Delta_\sigma$ (Planck)")
  plt.legend(loc="upper left", title=r"$\ell\in[50; 2000]$", bbox_to_anchor=(1,1))
#+END_SRC

#+RESULTS:
:results:
# Out[885]:
: <matplotlib.legend.Legend at 0x7fcbec53e7b8>
[[file:./obipy-resources/NM7IJU.png]]
:end:

**** Org table                                                  :noexport:
#+BEGIN_SRC ipython :session bcv :results raw output
  print(tabulate.tabulate(table, headers=labels, tablefmt="orgtbl"))
#+END_SRC

#+TBLNAME: min_l_50_2000
#+RESULTS:
|                               | $\theta_\mathrm{MC}$ | $A_\mathrm{s}$ | $n_\mathrm{s}$ | $\Omega_\mathrm{b}h^2$ | $\Omega_\mathrm{c}h^2$ | $\chi^2/\mathrm{ndf}$ |
|-------------------------------+----------------------+----------------+----------------+------------------------+------------------------+-----------------------|
| $\mu$(SOxSO)                  |            0.0104165 |    2.12888e-09 |       0.964796 |               0.022119 |               0.121061 |               1.00019 |
| $\mu$(SOxP)                   |            0.0104165 |    2.12863e-09 |       0.964918 |              0.0221197 |               0.121011 |               1.00034 |
| $\mu$(PxP)                    |            0.0104164 |    2.12876e-09 |       0.964918 |               0.022122 |               0.121043 |               1.00003 |
| $\sigma$(SOxSO)               |          4.35923e-06 |    1.19063e-11 |     0.00529269 |            0.000197395 |             0.00208537 |             0.0319118 |
| $\sigma$(SOxP)                |          4.70511e-06 |    1.28073e-11 |     0.00574473 |            0.000196329 |             0.00236035 |             0.0321642 |
| $\sigma$(PxP)                 |          5.16462e-06 |    1.32325e-11 |     0.00592473 |            0.000214703 |             0.00238011 |             0.0327516 |
| $\sigma$(SOxSO - PxP)         |          2.99731e-06 |    7.16794e-12 |     0.00314853 |            0.000122405 |             0.00133315 |             0.0201569 |
| $\sigma$(SOxSO - SOxP)        |          2.03202e-06 |    5.97189e-12 |     0.00261404 |            8.41646e-05 |             0.00127252 |             0.0126795 |
| $\sigma$(SOxSO + PxP - 2 SOxP |          3.05013e-06 |    9.43821e-12 |     0.00429037 |            0.000118191 |             0.00217506 |             0.0185606 |

** \ell \in [50; 1500]
#+BEGIN_SRC ipython :session bcv :results raw drawer
  params_SO   = get_params(r"/home/garrido/Workdir/CMB/analysis/beyondCV/output/ell_50_1500", "*SO.likelihood")
  params_SOxP = get_params(r"/home/garrido/Workdir/CMB/analysis/beyondCV/output/ell_50_1500", "*SOxP.likelihood")
  params_P    = get_params(r"/home/garrido/Workdir/CMB/analysis/beyondCV/output/ell_50_1500", "*_P.likelihood")
  params_SO.shape, params_SOxP.shape, params_P.shape
#+END_SRC

#+RESULTS:
:results:
# Out[886]:
: ((1001, 6), (1001, 6), (1001, 6))
:end:
*** Triangle plot
#+BEGIN_SRC ipython :session bcv :results none
  samples_SO   = MCSamples(samples=params_SO, names=labels, label="SOxSO")
  samples_SOxP = MCSamples(samples=params_SOxP, names=labels, label="SOxP")
  samples_P    = MCSamples(samples=params_P, names=labels, label="PxP")
#+END_SRC

#+BEGIN_SRC ipython :session bcv :results raw drawer
  g = plots.getSubplotPlotter()
  g.triangle_plot([samples_SO, samples_SOxP, samples_P], params=labels[:-1])
  show_ref(g)
#+END_SRC

#+RESULTS:
:results:
# Out[888]:
[[file:./obipy-resources/QXWKEY.png]]
:end:

*** Variances of parameters
#+BEGIN_SRC ipython :session bcv :results none
  lines = [[r"$\mu$(SOxSO)"], [r"$\mu$(SOxP)"], [r"$\mu$(PxP)"],
           [r"$\sigma$(SOxSO)"], [r"$\sigma$(SOxP)"], [r"$\sigma$(PxP)"],
           [r"$\sigma$(SOxSO - PxP)"], [r"$\sigma$(SOxSO - SOxP)"], [r"$\sigma$(SOxSO + PxP - 2 SOxP)"]]
  std_SO, std_SOxP, std_P = np.std(params_SO, axis=0), np.std(params_SOxP, axis=0), np.std(params_P, axis=0)
  std_SOmP = np.std(params_SO-params_P, axis=0)
  std_SOmSOxP = np.std(params_SO-params_SOxP, axis=0)
  std_SOpPm2SOxP = np.std(params_SO + params_P - 2*params_SOxP, axis=0)
  table = np.stack([np.mean(params_SO, axis=0),
                    np.mean(params_SOxP, axis=0),
                    np.mean(params_P, axis=0),
                    std_SO, std_SOxP, std_P,
                    std_SOmP, std_SOmSOxP, std_SOpPm2SOxP
  ])
  table = np.append(lines, table, axis=1)
  display(HTML(tabulate.tabulate(table, headers=labels, tablefmt="html")))
#+END_SRC

#+BEGIN_SRC ipython :session bcv :results raw drawer
  x = np.arange(5)
  plt.plot(x, (ref_std/std_SO-1)[:-1], "o", label="SO")
  plt.plot(x, (ref_std/std_SOxP-1)[:-1], "o", label="SOxP")
  plt.plot(x, (ref_std/std_SOmP-1)[:-1], "o", label="SO-P")
  plt.plot(x, (ref_std/std_SOmSOxP-1)[:-1], "o", label="SO-SOxP")
  plt.plot(x, (ref_std/std_SOpPm2SOxP-1)[:-1], "o", label="SO+P-2SOxP")
  plt.xticks(x, labels[:-1])
  plt.ylabel(r"$\Delta_\sigma$ (Planck)")
  plt.legend(loc="upper left", title=r"$\ell\in[50; 1500]$", bbox_to_anchor=(1,1))
#+END_SRC

#+RESULTS:
:results:
# Out[890]:
: <matplotlib.legend.Legend at 0x7fcbe69a05c0>
[[file:./obipy-resources/qVqYAE.png]]
:end:

**** Org table                                                  :noexport:
#+BEGIN_SRC ipython :session bcv :results raw output
  print(tabulate.tabulate(table, headers=labels, tablefmt="orgtbl"))
#+END_SRC

#+TBLNAME: min_l_50_1500
#+RESULTS:
|                                | $\theta_\mathrm{MC}$ | $A_\mathrm{s}$ | $n_\mathrm{s}$ | $\Omega_\mathrm{b}h^2$ | $\Omega_\mathrm{c}h^2$ | $\chi^2-\chi^2_\mathrm{min}$ |
|--------------------------------+----------------------+----------------+----------------+------------------------+------------------------+------------------------------|
| $\mu$(SOxSO)                   |            0.0104164 |    2.12863e-09 |       0.965054 |              0.0221352 |               0.120982 |                      438.048 |
| $\mu$(SOxP)                    |            0.0104164 |    2.12874e-09 |       0.964994 |              0.0221343 |               0.121002 |                      432.316 |
| $\mu$(PxP)                     |            0.0104164 |    2.12879e-09 |       0.964959 |              0.0221337 |                0.12101 |                      419.556 |
| $\sigma$(SOxSO)                |          6.33122e-06 |    1.52994e-11 |     0.00712238 |             0.00025782 |             0.00282717 |                      109.152 |
| $\sigma$(SOxP)                 |          6.34361e-06 |    1.52274e-11 |     0.00707437 |            0.000258408 |             0.00281993 |                      109.211 |
| $\sigma$(PxP)                  |          6.51112e-06 |    1.54247e-11 |     0.00720613 |            0.000264971 |             0.00285429 |                      109.122 |
| $\sigma$(SOxSO - PxP)          |          1.83962e-06 |    4.23374e-12 |     0.00213334 |            7.39648e-05 |            0.000775876 |                      34.0135 |
| $\sigma$(SOxSO - SOxP)         |          9.87789e-07 |    2.64961e-12 |     0.00126339 |            4.27526e-05 |            0.000494945 |                       17.241 |
| $\sigma$(SOxSO + PxP - 2 SOxP) |          8.42738e-07 |    3.20894e-12 |     0.00141523 |            4.80156e-05 |            0.000616931 |                      9.56108 |

** Correlation of parameters
*** Correlation between experiments PxP, SOxSO
#+BEGIN_SRC ipython :session :results none
  import matplotlib.pyplot as plt
  import pandas as pd
  import numpy as np

  def get_params(path, pattern="*.likelihood"):
      import os, glob
      all_files = glob.glob(os.path.join(path, pattern))
      # Sort alphabetically
      all_files.sort()

      header = pd.read_csv(all_files[0], delim_whitespace=True).columns[1:]
      df = pd.concat((pd.read_table(f, delim_whitespace=True) for f in all_files))

      # Remove '#' in header
      df.drop(df.columns[[-1,]], axis=1, inplace=True)
      df.columns = header
      # Compute delta chi2
      delta_chi2 = df.chi2-np.min(df.chi2)
      # Remove useless columns
      df.drop(columns=["weight", "minuslogpost", "minuslogprior", "minuslogprior__0", "chi2", "chi2__chi2"], inplace=True)
      # Insert Delta chi2 before As (which is derived and never plot)
      df.insert(value=delta_chi2, column="delta_chi2", loc=len(df.columns))

      return np.array(df)
#+END_SRC

#+BEGIN_SRC ipython :session :results none
  # Get data
  lmin = 50
  lmaxs = [750, 1500, 3000]#, 3000]
  params_SO = {}
  params_P = {}
  output_base = r"/home/garrido/Workdir/CMB/analysis/beyondCV/output/correlation_matrix/"
  for i, lmax in enumerate(lmaxs):
      params_SO[lmax] = get_params(output_base + "results_lmin{}_lmax{}_SOxSO_*".format(lmin, lmax), "*.likelihood")
      params_P[lmax]  = get_params(output_base + "results_lmin{}_lmax{}_PxP_*".format(lmin, lmax), "*.likelihood")
      print("lmax = ", lmax, params_P[lmax].shape, params_SO[lmax].shape)
#+END_SRC

#+BEGIN_SRC ipython :session :results none
  def get_corrcoef(params1, params2, cols=None, split=False, nsplit=100):
      n = len(cols)
      if split:
          split1 = np.array_split(params1, nsplit)
          split2 = np.array_split(params2, nsplit)
          corrcoef = np.empty((nsplit, n))
          for i in range(nsplit):
              for j in range(n):
                  P1, P2 = split1[i][:,cols[j]], split2[i][:,cols[j]]
                  corrcoef[i, j] = np.corrcoef(P1, P2)[0, 1]
          return np.mean(corrcoef, axis=0), np.std(corrcoef, axis=0)/np.sqrt(nsplit)
      else:
          corrcoef = np.empty(n)
          for i in range(n):
              P1, P2 = params1[:,cols[i]], params2[:,cols[i]]
              corrcoef[i] = np.corrcoef(P1, P2)[0, 1]
          return corrcoef
#+END_SRC

#+BEGIN_SRC ipython :session :results raw drawer
  labels = [r"$\theta_{\rm MC}$",
            r"$\log(10^{10}A_\mathrm{s})$",
            r"$n_\mathrm{s}$",
            r"$\Omega_\mathrm{b}h^2$",
            r"$\Omega_\mathrm{c}h^2$",
            r"$\mathrm{A}_\mathrm{L}$",
            r"$A_S$",
            r"$H_0$"]
  cols = [7, 1, 2, 3, 4, 5, 0]
  n = len(cols)

  def plot_multiple_correlation(params1, params2, x, col2colors):
      n = params1.shape[1]
      Rxx = np.corrcoef(params1, rowvar=False)
      c = np.corrcoef(params1, params2, rowvar=False)
      c = c[:n, n:]

      R2 = (c.T).dot(np.linalg.inv(Rxx)).dot(c)
      R = np.sqrt(R2.diagonal())
      for i in range(n):
          plt.plot(x, R[i], "-o", color="C{}".format(col2colors[i]))


  split = False
  multiple_correlation = False
  if split:
      corr_coeff_means = np.empty((np.alen(lmaxs), n))
      corr_coeff_errs = np.empty((np.alen(lmaxs), n))
      for i, lmax in enumerate(lmaxs):
          corr_coeff_mean, corr_coeff_err = get_corrcoef(params_SO[lmax], params_P[lmax], cols=cols, split=split)
          corr_coeff_means[i] = corr_coeff_mean
          corr_coeff_errs[i] = corr_coeff_err
  else:
      corr_coeffs = np.empty((np.alen(lmaxs), n))
      for i, lmax in enumerate(lmaxs):
          if multiple_correlation:
              Rxx = np.corrcoef(params_P[lmax], rowvar=False)
              c = np.corrcoef(params_P[lmax], params_SO[lmax], rowvar=False)
              c = c[:Rxx.shape[0], Rxx.shape[0]:]

              R2 = (c.T).dot(np.linalg.inv(Rxx)).dot(c)
              R = np.sqrt(R2.diagonal())
              for j, c in enumerate(cols):
                  corr_coeffs[i, j] = R[c]
          else:
              corr_coeff = get_corrcoef(params_P[lmax], params_SO[lmax], cols=cols, split=split)
              corr_coeffs[i] = corr_coeff

  for i in range(n):
      if split:
          plt.errorbar(lmaxs, corr_coeff_means[:, i], yerr=corr_coeff_errs[:, i], fmt="-o", label=labels[cols[i]])
      else:
          plt.plot(lmaxs, corr_coeffs[:, i], "-o", label=labels[cols[i]])

  plt.xlabel(r"$\ell_{\rm max}$")
  plt.ylabel(r"$R_{xy}$")
  plt.legend(loc="upper left", bbox_to_anchor=(1,1))
#+END_SRC

#+RESULTS:
:results:
# Out[75]:
: <matplotlib.legend.Legend at 0x7f687e2c2240>
[[file:./obipy-resources/nWIOqw.png]]
:end:

Simulation corrélées

#+RESULTS:
:results:
# Out[35]:
: <matplotlib.legend.Legend at 0x7f3210aebf98>
[[file:./obipy-resources/3yEhy0.png]]
:end:

*** Correlation between PxP and SOxSO regarding \theta_{MC} /vs./ H_0 /vs./ Alens
**** Simple correlation
#+BEGIN_SRC ipython :session :results none
  def plot_corrcoeff(params1, params2, col2colors, split=True, lmax=1500):
    n = len(col2colors.keys())
    if split:
        corr_coeff_means = np.empty(n)
        corr_coeff_errs = np.empty(n)
        corr_coeff_mean, corr_coeff_err = get_corrcoef(params1, params2,
                                                       cols=list(col2colors.keys()), split=split)
        corr_coeff_means = corr_coeff_mean
        corr_coeff_errs = corr_coeff_err
    else:
        corr_coeffs = np.empty(n)
        corr_coeff = get_corrcoef(params1, params2,
                                  cols=list(col2colors.keys()), split=split)
        corr_coeffs = corr_coeff

    print(corr_coeff_means, corr_coeff_errs)

    for i in range(n):
        if split:
            plt.errorbar(lmax, corr_coeff_means[i], yerr=corr_coeff_errs[i], fmt="-o", color="C{}".format(col2colors[i]))
        else:
            plt.plot(lmax, corr_coeffs[i], "-o", color="C{}".format(col2colors[i]))

    # plt.xlabel(r"$\ell_{\rm max}$")
    plt.ylabel(r"$R_{xy}$")
#+END_SRC

Get cosmological parameters
#+BEGIN_SRC ipython :session :results none
  lmin = 50
  lmax = 1500
  output_base = r"/home/garrido/Workdir/CMB/analysis/beyondCV/output/coeff_corr_fixAlens/"
  params_P_thetaMC_fixAlens = get_params(output_base + "results_lmin{}_lmax{}_PxP_*".format(lmin, lmax), "*.likelihood")
  params_SO_thetaMC_fixAlens = get_params(output_base + "results_lmin{}_lmax{}_SOxSO_*".format(lmin, lmax), "*.likelihood")
  print(params_P_thetaMC_fixAlens.shape, params_SO_thetaMC_fixAlens.shape)

  output_base = r"/home/garrido/Workdir/CMB/analysis/beyondCV/output/coeff_corr_thetaMC+Alens/"
  params_P_thetaMC_Alens = get_params(output_base + "results_lmin{}_lmax{}_PxP_*".format(lmin, lmax), "*.likelihood")
  params_SO_thetaMC_Alens = get_params(output_base + "results_lmin{}_lmax{}_SOxSO_*".format(lmin, lmax), "*.likelihood")
  print(params_P_thetaMC_Alens.shape, params_SO_thetaMC_Alens.shape)

  output_base = r"/home/garrido/Workdir/CMB/analysis/beyondCV/output/coeff_corr_fixAlens_H0/"
  params_P_H0_fixAlens = get_params(output_base + "results_lmin{}_lmax{}_PxP_*".format(lmin, lmax), "*.likelihood")
  params_SO_H0_fixAlens = get_params(output_base + "results_lmin{}_lmax{}_SOxSO_*".format(lmin, lmax), "*.likelihood")
  print(params_P_H0_fixAlens.shape, params_SO_H0_fixAlens.shape)

  output_base = r"/home/garrido/Workdir/CMB/analysis/beyondCV/output/coeff_corr_H0+Alens/"
  params_P_H0_Alens = get_params(output_base + "results_lmin{}_lmax{}_PxP_*".format(lmin, lmax), "*.likelihood")
  params_SO_H0_Alens = get_params(output_base + "results_lmin{}_lmax{}_SOxSO_*".format(lmin, lmax), "*.likelihood")
  print(params_P_H0_Alens.shape, params_SO_H0_Alens.shape)
#+END_SRC

#+BEGIN_SRC ipython :session :results raw drawer
  labels = [r"$\theta_{\rm MC}$",
            r"$\log(10^{10}A_\mathrm{s})$",
            r"$n_\mathrm{s}$",
            r"$\Omega_\mathrm{b}h^2$",
            r"$\Omega_\mathrm{c}h^2$",
            r"$H_0$",
            r"$\mathrm{A}_\mathrm{L}$",
            r"$A_S$"]

  split=True

  cols2colors = {0:0, 1:1, 2:2, 3:3, 4:4}
  plot_corrcoeff(params_SO_thetaMC_fixAlens, params_P_thetaMC_fixAlens, cols2colors, lmax=1, split=split)

  cols2colors = {0:0, 1:1, 2:2, 3:3, 4:4, 5:6}
  plot_corrcoeff(params_SO_thetaMC_Alens, params_P_thetaMC_Alens, cols2colors, lmax=2, split=split)

  cols2colors = {0:5, 1:1, 2:2, 3:3, 4:4}
  plot_corrcoeff(params_SO_H0_fixAlens, params_P_H0_fixAlens, cols2colors, lmax=3, split=split)

  cols2colors = {0:5, 1:1, 2:2, 3:3, 4:4, 5:6}
  plot_corrcoeff(params_SO_H0_Alens, params_P_H0_Alens, cols2colors, lmax=4, split=split)

  plt.xticks([1, 2, 3, 4],
             [r"$\theta_{\rm MC}$ + fix $\mathrm{A}_\mathrm{L}$",
              r"$\theta_{\rm MC} + \mathrm{A}_\mathrm{L}$",
              r"$H_0$ + fix $\mathrm{A}_\mathrm{L}$",
              r"$H_0 + \mathrm{A}_\mathrm{L}$"])

  for i in labels[:-1]:
    plt.plot([], [], "o", label=i)
  plt.legend(loc="upper left", bbox_to_anchor=(1,1))

#+END_SRC

#+RESULTS:
:results:
# Out[105]:
: <matplotlib.legend.Legend at 0x7ff8981a1048>
[[file:./obipy-resources/V11SKw.png]]
:end:

**** Multiple correlation

#+BEGIN_SRC ipython :session :results raw drawer
  def plot_multiple_correlation(params1, params2, x, col2colors):
      n = params1.shape[1]
      Rxx = np.corrcoef(params1, rowvar=False)
      c = np.corrcoef(params1, params2, rowvar=False)
      c = c[:n, n:]

      R2 = (c.T).dot(np.linalg.inv(Rxx)).dot(c)
      R = np.sqrt(R2.diagonal())
      for i in range(n):
          plt.plot(x, R[i], "-o", color="C{}".format(col2colors[i]))

  cols2colors = {0:0, 1:1, 2:2, 3:3, 4:4}
  plot_multiple_correlation(params_P_thetaMC_fixAlens[:, :5], params_SO_thetaMC_fixAlens[: ,:5], 1, cols2colors)

  cols2colors = {0:0, 1:1, 2:2, 3:3, 4:4, 5:6}
  plot_multiple_correlation(params_P_thetaMC_Alens[:, :6], params_SO_thetaMC_Alens[:, :6], 2, cols2colors)

  cols2colors = {0:5, 1:1, 2:2, 3:3, 4:4}
  plot_multiple_correlation(params_P_H0_fixAlens[:, :5], params_SO_H0_fixAlens[:, :5], 3, cols2colors)

  cols2colors = {0:5, 1:1, 2:2, 3:3, 4:4, 5:6}
  plot_multiple_correlation(params_P_H0_Alens[:, :6], params_SO_H0_Alens[:, :6], 4, cols2colors)

  labels = [r"$\theta_{\rm MC}$",
            r"$\log(10^{10}A_\mathrm{s})$",
            r"$n_\mathrm{s}$",
            r"$\Omega_\mathrm{b}h^2$",
            r"$\Omega_\mathrm{c}h^2$",
            r"$H_0$",
            r"$\mathrm{A}_\mathrm{L}$",
            r"$A_S$"]
  plt.xticks([1, 2, 3, 4],
             [r"$\theta_{\rm MC}$ + fix $\mathrm{A}_\mathrm{L}$",
              r"$\theta_{\rm MC} + \mathrm{A}_\mathrm{L}$",
              r"$H_0$ + fix $\mathrm{A}_\mathrm{L}$",
              r"$H_0 + \mathrm{A}_\mathrm{L}$"])

  for i in labels[:-1]:
    plt.plot([], [], "o", label=i)
  plt.legend(loc="upper left", bbox_to_anchor=(1,1))
#+END_SRC

#+RESULTS:
:results:
# Out[160]:
: <matplotlib.legend.Legend at 0x7ff89305b748>
[[file:./obipy-resources/D8TWbr.png]]
:end:

**** Check \chi^2 distribution for 10 simulations
#+BEGIN_SRC ipython :session :results raw drawer
  output_base = r"/home/garrido/Workdir/CMB/analysis/beyondCV/output/minimize_thetaMC+fixAlens/"
  chi2_P_thetaMC_fixAlens = get_params(output_base + "results_PxP_*", "*.likelihood")[:, -1]

  output_base = r"/home/garrido/Workdir/CMB/analysis/beyondCV/output/minimize_thetaMC+Alens/"
  chi2_P_thetaMC_Alens = get_params(output_base + "results_PxP_*", "*.likelihood")[:, -1]
  chi2_P_thetaMC_Alens = chi2_P_thetaMC_Alens[chi2_P_thetaMC_Alens < 5]

  output_base = r"/home/garrido/Workdir/CMB/analysis/beyondCV/output/minimize_H0+fixAlens/"
  chi2_P_H0_fixAlens = get_params(output_base + "results_PxP_*", "*.likelihood")[:,-1]

  output_base = r"/home/garrido/Workdir/CMB/analysis/beyondCV/output/minimize_H0+Alens/"
  chi2_P_H0_Alens = get_params(output_base + "results_PxP_*", "*.likelihood")[:,-1]

  print(chi2_P_thetaMC_fixAlens.shape)
  print(chi2_P_thetaMC_Alens.shape)
  print(chi2_P_H0_fixAlens.shape)
  print(chi2_P_H0_Alens.shape)

  plt.plot(np.full_like(chi2_P_thetaMC_fixAlens, 1), chi2_P_thetaMC_fixAlens, "o")
  plt.plot(np.full_like(chi2_P_thetaMC_Alens, 2), chi2_P_thetaMC_Alens, "o")
  plt.plot(np.full_like(chi2_P_H0_fixAlens, 3), chi2_P_H0_fixAlens, "o")
  plt.plot(np.full_like(chi2_P_H0_Alens, 4), chi2_P_H0_Alens, "o")

  plt.xticks([1, 2, 3, 4],
             [r"$\theta_{\rm MC}$ + fix $\mathrm{A}_\mathrm{L}$",
              r"$\theta_{\rm MC} + \mathrm{A}_\mathrm{L}$",
              r"$H_0$ + fix $\mathrm{A}_\mathrm{L}$",
              r"$H_0 + \mathrm{A}_\mathrm{L}$"])
  plt.ylabel(r"$\chi^2-\chi^2_{\rm min}$")

#+END_SRC

#+RESULTS:
:results:
# Out[133]:
: Text(0,0.5,'$\\chi^2-\\chi^2_{\\rm min}$')
[[file:./obipy-resources/V0Fj87.png]]
:end:

*** Comparison of the variances

#+BEGIN_SRC ipython :session :results none
  def get_stds(lmin=50, lmax=3000, nvar=6):
      return np.std(params_SO[lmax][:, :nvar], axis=0), np.std(params_P[lmax][:,:nvar], axis=0)

  stds_SO = np.empty((np.alen(lmaxs), nvar))
  stds_P = np.empty((np.alen(lmaxs), nvar))
  for i, lmax in enumerate(lmaxs):
      std_SO, std_P = get_stds(lmin, lmax, nvar)
      stds_SO[i] = std_SO
      stds_P[i] = std_P
#+END_SRC

#+BEGIN_SRC ipython :session :results raw drawer
  for i in range(nvar):
      plt.plot(lmaxs, stds_SO[:, i]/stds_SO[0, i], "-o", label=labels[i])

  plt.xlabel(r"$\ell_{\rm max}$")
  plt.ylabel(r"$\sigma/\sigma_{500}$")
  plt.title(r"SO standard deviation")
  plt.legend(loc="upper left", bbox_to_anchor=(1,1))
#+END_SRC
#+RESULTS:
:results:
# Out[28]:
: <matplotlib.legend.Legend at 0x7f0db1cbda90>
[[file:./obipy-resources/6FeXYp.png]]
:end:

#+BEGIN_SRC ipython :session :results raw drawer
  for i in range(nvar):
      plt.plot(lmaxs, stds_P[:, i]/stds_P[0, i], "-o", label=labels[i])

  plt.xlabel(r"$\ell_{\rm max}$")
  plt.ylabel(r"$\sigma/\sigma_{500}$")
  plt.title(r"Planck standard deviation")
  plt.legend(loc="upper left", bbox_to_anchor=(1,1))
#+END_SRC

#+RESULTS:
:results:
# Out[29]:
: <matplotlib.legend.Legend at 0x7f0dadb6cd30>
[[file:./obipy-resources/RGBkG2.png]]
:end:

#+BEGIN_SRC ipython :session :results raw drawer
  for i in range(nvar):
      plt.plot(lmaxs, stds_SO[:, i]/stds_P[:, i], "-o", label=labels[i])

  plt.xlabel(r"$\ell_{\rm max}$")
  plt.ylabel(r"$\sigma_{SOxSO}/\sigma_{PxP}$")
  plt.legend(loc="upper left", bbox_to_anchor=(1,1))
#+END_SRC

#+RESULTS:
:results:
# Out[30]:
: <matplotlib.legend.Legend at 0x7f0dae3e2710>
[[file:./obipy-resources/BTJE15.png]]
:end:

*** Correlation of cosmo. parameters /vs./ \ell_{max}
#+BEGIN_SRC ipython :session :results raw drawer
  labels = [r"$H_0$",
            r"$\log(10^{10}A_\mathrm{s})$",
            r"$n_\mathrm{s}$",
            r"$\Omega_\mathrm{b}h^2$",
            r"$\Omega_\mathrm{c}h^2$",
            r"$\mathrm{A}_\mathrm{L}$"]
  corr_coeffs_P = np.empty((nvar, np.alen(lmaxs), nvar))
  corr_coeffs_SO = np.empty((nvar, np.alen(lmaxs), nvar))
  for i, lmax in enumerate(lmaxs):
      corr_coeff_P = np.corrcoef(params_P[lmax].T)
      corr_coeff_SO = np.corrcoef(params_SO[lmax].T)
      for j in range(nvar):
          corr_coeffs_P[j, i] = corr_coeff_P[j][:-2]
          corr_coeffs_SO[j, i] = corr_coeff_SO[j][:-2]

  fig, ax = plt.subplots(2, 3, sharey=True, sharex=True, figsize=(10,6))
  for i in range(nvar):
      ax[i//3, i%3].plot(lmaxs, corr_coeffs_P[i], "o-")
      ax[0, -1].plot([], [], label=labels[i], color="C{}".format(i))

  fig.tight_layout()
  fig.text(0.5, -0.02, r"$\ell_{\rm max}$", ha="center", size=14)
  fig.text(-0.02, 0.5, r"$R_{xy}$", va="center", rotation="vertical", size=14)
  fig.text(0.5, 1, r"PxP", va="center", size=14)
  ax[0, -1].legend(loc="upper left", bbox_to_anchor=(1,1))

#+END_SRC

#+RESULTS:
:results:
# Out[38]:
: <matplotlib.legend.Legend at 0x7fcccf4b9e48>
[[file:./obipy-resources/IxszcK.png]]
:end:

#+BEGIN_SRC ipython :session :results raw drawer
    fig, ax = plt.subplots(2, 3, sharey=True, sharex=True, figsize=(10,6))
    for i in range(nvar):
        ax[i//3, i%3].plot(lmaxs, corr_coeffs_SO[i], "o-")
        ax[0, -1].plot([], [], label=labels[i], color="C{}".format(i))

    fig.tight_layout()
    fig.text(0.5, -0.02, r"$\ell_{\rm max}$", ha="center", size=14)
    fig.text(-0.02, 0.5, r"$R_{xy}$", va="center", rotation="vertical", size=14)
    fig.text(0.5, 1, r"SOxSO", va="center", size=14)
    ax[0, -1].legend(loc="upper left", bbox_to_anchor=(1,1))
#+END_SRC

#+RESULTS:
:results:
# Out[39]:
 : <matplotlib.legend.Legend at 0x7fccd44c1be0>
[[file:./obipy-resources/5ETQte.png]]
:end:

*** Correlation matrices
#+BEGIN_SRC ipython :session :results none
  lmin = 50
  lmaxs = [750, 1500, 3000]
  params_P = {}
  params_SO = {}
  params_SOxP = {}
  output_base = r"/home/garrido/Workdir/CMB/analysis/beyondCV/output/correlation_matrix/"
  for lmax in lmaxs:
      params_P[lmax]  = get_params(output_base + "results_lmin{}_lmax{}_PxP_*".format(lmin, lmax), "*.likelihood")
      params_SO[lmax] = get_params(output_base + "results_lmin{}_lmax{}_SOxSO_*".format(lmin, lmax), "*.likelihood")
      params_SOxP[lmax]  = get_params(output_base + "results_lmin{}_lmax{}_SOxP_*".format(lmin, lmax), "*.likelihood")
      print(lmax, params_P[lmax].shape, params_SO[lmax].shape, params_SOxP[lmax].shape)
#+END_SRC

#+BEGIN_SRC ipython :session :results none
  labels = [
    r"$\theta_\mathrm{MC}$",
    r"$\log(10^{10}A_\mathrm{s})$",
    r"$n_\mathrm{s}$",
    r"$\Omega_\mathrm{b}h^2$",
    r"$\Omega_\mathrm{c}h^2$",
    r"$\mathrm{A}_\mathrm{L}$",
    r"$A_S$",
    r"$H_0$",
    r"$\chi^2-\chi^2_\mathrm{min}$"]

  def plot_minimization_distribution(params):
    from getdist import plots, MCSamples
    samples = MCSamples(samples=params, names=labels)
    g = plots.getSubplotPlotter()
    g.settings.colormap = "inferno"
    g.triangle_plot(samples, params=labels, shaded=True)

    ref = [0.0104085, 3.044, 0.9649, 0.02237, 0.1200, 1.0, np.exp(3.044)/1e10, 67.36]
    for i, r in enumerate(ref):
      kwargs = dict(color="gray", ls="--", lw=1)
      for ax in g.subplots[:,i]:
        if ax: ax.axvline(r, **kwargs)
      for ax in g.subplots[i,:i]:
        if ax: ax.axhline(r, **kwargs)
    return samples
#+END_SRC

#+BEGIN_SRC ipython :session :results raw drawer
  samples = plot_minimization_distribution(params_SOxP[750])
#+END_SRC

#+RESULTS:
:results:
# Out[7]:
[[file:./obipy-resources/uLyWKd.png]]
:end:

#+BEGIN_SRC ipython :session :results raw drawer
  fisher = {}
  fisher[750] = np.array([2.594838237812317e-05, 0.017560000164131256, 0.030566465711409373, 0.000978442350299659, 0.008173529810644575, 0.8648195038180473])
  fisher[1500] = np.array([7.2387579903814184e-06, 0.008889021975948657, 0.00917487752126064, 0.0003546333574293694, 0.003597119918133382, 0.12172060190582654])
  fisher[3000] = np.array([5.509955450251826e-06, 0.007142331825784332, 0.0064611131716016176, 0.00023077117354014425, 0.002810559755895622, 0.07295249635085933])
  x = np.arange(0, len(fisher[lmax]))
  for i, lmax in enumerate(lmaxs):
      y = (np.std(params_P[lmax], axis=0)[:len(fisher[lmax])] - fisher[lmax])/fisher[lmax]*100
      plt.plot(x, y, "oC{}".format(i), label="{}".format(lmax))
      y = (np.std(params_SO[lmax], axis=0)[:len(fisher[lmax])] - fisher[lmax])/fisher[lmax]*100
      plt.plot(x, y, "sC{}".format(i))
      y = (np.std(params_SOxP[lmax], axis=0)[:len(fisher[lmax])] - fisher[lmax])/fisher[lmax]*100
      plt.plot(x, y, "^C{}".format(i))

  plt.xticks(x, labels[:len(fisher[750])])
  plt.ylabel(r"$\Delta\sigma$ [%]")
  plt.plot([], [], "ok", label="PxP")
  plt.plot([], [], "sk", label="SOxSO")
  plt.plot([], [], "^k", label="SOxP")
  plt.legend(ncol=2, loc="upper left", bbox_to_anchor=(1,1))
#+END_SRC

#+RESULTS:
:results:
# Out[12]:
: <matplotlib.legend.Legend at 0x7fefa636eeb8>
[[file:./obipy-resources/mB97gd.png]]
:end:

#+BEGIN_SRC ipython :session :results raw drawer
  labels = [
    r"$H_0$",
    r"$n_\mathrm{s}$",
    r"$\Omega_\mathrm{b}h^2$",
    r"$\Omega_\mathrm{c}h^2$",
    r"$\mathrm{A}_\mathrm{L}$"]

  n = len(labels)
  nl = len(lmaxs)

  fig, ax = plt.subplots(nrows=1, ncols=3, sharex=True, figsize=(26,26))

  for i, lmax in enumerate(lmaxs):
      # Swap H0 as first and delete useless columns
      P = np.copy(params_P[lmax])
      SO = np.copy(params_SO[lmax])
      SOxP = np.copy(params_SOxP[lmax])
      P[:, 0] = P[:, 7]
      SO[:, 0] = SO[:, 7]
      SOxP[:, 0] = SOxP[:, 7]
      P = np.delete(P, [1, 6, 7, 8], axis=1)
      SO = np.delete(SO, [1, 6, 7, 8], axis=1)
      SOxP = np.delete(SOxP, [1, 6, 7, 8], axis=1)

      rxx_data = np.concatenate([P, SOxP, SO], axis=1)

      # Rxx = np.corrcoef(P, SO, rowvar=False)
      Rxx = np.corrcoef(rxx_data, rowvar=False)
      im = ax[i].imshow(Rxx, cmap=plt.cm.RdBu, vmin=-1, vmax=+1)
      ns = rxx_data.shape[1]//n
      ax[i].set_xticks(np.arange(0, ns*n))
      ax[i].set_xticklabels(ns*labels, fontsize=12)
      ax[i].set_yticks(np.arange(0, ns*n))
      ax[i].set_yticklabels([])
      ax[i].axvline(4.5, linestyle="--", color="black")
      ax[i].axvline(9.5, linestyle="--", color="black")
      ax[i].axhline(4.5, linestyle="--", color="black")
      ax[i].axhline(9.5, linestyle="--", color="black")

  ax[0].set_yticklabels(ns*labels, fontsize=12)
  ax[-1].set_yticklabels(ns*labels, fontsize=12)
  ax[-1].yaxis.tick_right()
  ax[-1].yaxis.set_ticks_position("both")

  fig.subplots_adjust(wspace=0.05)

  # cbar_ax = fig.add_axes([0.95, 0.375, 0.01, 0.25])
  # cbar = fig.colorbar(im, cax=cbar_ax)
  # cbar.ax.tick_params(labelsize=12)
  # cbar.set_label("correlation", fontsize=14)

  cbar_ax = fig.add_axes([0.21, 0.32, 0.61, 0.015])
  cbar = fig.colorbar(im, cax=cbar_ax, orientation="horizontal")
  cbar.ax.tick_params(labelsize=12)
  cbar.set_label("correlation", fontsize=14)

  kwargs1 = dict(xycoords='axes fraction', arrowprops=dict(arrowstyle='|-|, widthA=0.2, widthB=0.2', color="black"))
  kwargs2 = dict(transform=ax[0].transAxes, color="black")

  survey = ["PxP", "SOxP", "SOxSO"]
  ns = len(survey)
  for i in range(ns):
      ax[0].annotate("", xy=(i/ns, 1.05), xytext=((i+1)/ns, 1.05), **kwargs1)
      ax[0].annotate("", xy=(-0.1, i/ns), xytext=(-0.1, (i+1)/ns), **kwargs1)
      ax[0].text((2*i+1)/(2*ns), 1.05, survey[i], **kwargs2, ha="center", va="bottom", fontsize=14)
      ax[0].text(-0.1, (2*i+1)/(2*ns), survey[ns-i-1], **kwargs2, va="center", ha="right", rotation=90, fontsize=14)

  for i in range(nl):
    # ax[i].annotate("", xy=(-0.15, 1.0), xytext=(-0.15, 0.0), **kwargs1)
    ax[i].text(0.5, -0.1, r"$\ell_\mathrm{max}$ = " + str(lmaxs[i]),
               transform=ax[i].transAxes, ha="center", fontsize=14)
#+END_SRC

#+RESULTS:
:results:
# Out[14]:
[[file:./obipy-resources/Pnz3CA.png]]
:end:

** Correlation of spectra
#+BEGIN_SRC ipython :session :results none
  import matplotlib.pyplot as plt
  import numpy as np
  import pickle

  def load_spectra(path, pattern="*.pkl", nell=0):
      import os, glob
      all_files = glob.glob(os.path.join(path, pattern))
      # Sort alphabetically
      all_files.sort()
      Dls = np.empty((len(all_files), nell))
      for i, f in enumerate(all_files):
          Dl = pickle.load(open(f, "rb"))["setup"]["simulation"]["Dl"]
          Dls[i] = Dl

      return Dls.T
#+END_SRC

#+BEGIN_SRC ipython :session :results raw drawer
  nell = 3000 - 50
  output_base = r"/home/garrido/Workdir/CMB/analysis/beyondCV/output/correlation_matrix/"
  Dl_P = load_spectra(output_base + "results_lmin50_lmax{}_PxP_*".format(nell+50), nell=nell)
  Dl_SO = load_spectra(output_base + "results_lmin50_lmax{}_SOxSO_*".format(nell+50), nell=nell)
  corrcoeffs = np.empty((nell))
  for ell in range(nell):
    corrcoeffs[ell] = np.corrcoef(Dl_P[ell], Dl_SO[ell])[0, 1]

  ells = np.arange(50, 50+nell)
  plt.plot(ells, corrcoeffs)
  plt.xlabel(r"$\ell$")
  plt.ylabel(r"$R_{D_\ell^{PxP},\,D_\ell^{SOxSO}}$")
#+END_SRC

#+RESULTS:
:results:
# Out[78]:
: Text(0,0.5,'$R_{D_\\ell^{PxP},\\,D_\\ell^{SOxSO}}$')
[[file:./obipy-resources/m1f6BV.png]]
:end:

* MCMC analysis
#+BEGIN_SRC ipython :session :results none
  import pandas as pd
  def get_chains(path):
      import glob
      all_files = glob.glob(path)
      # Sort alphabetically
      all_files.sort()
      chains = {}
      for f in all_files:
          header = pd.read_csv(all_files[0], delim_whitespace=True).columns[1:]
          df = pd.read_table(f, delim_whitespace=True)

          # Remove '#' in header
          df.drop(df.columns[[-1,]], axis=1, inplace=True)
          df.columns = header
          # Compute delta chi2
          delta_chi2 = df.chi2-np.min(df.chi2)

          # Remove useless columns
          df.drop(columns=["minuslogpost", "minuslogprior", "minuslogprior__0", "chi2", "chi2__chi2", "As"], inplace=True)
          # Insert Delta chi2 before As (which is derived and never plot)
          df.insert(value=delta_chi2, column="delta_chi2", loc=len(df.columns))
          key = f.split("/")[-2]
          chains[key] = df
      return chains

  ref = [0.0104085, 3.044, 0.9649, 0.02237, 0.1200, 1, 67.36]
  def plot_chains(path, burnin=0, labels=labels):
      chains = get_chains(path=path)
      plt.figure(figsize=(18, 10))
      for i in range(1, len(labels)+1):
          plt.subplot(2, 4, i)
          plt.ylabel(labels[i-1])
          for k, v in chains.items():
              j = k.split("_")[-1]
              n = np.arange(len(v))
              ist = 0
              if 0 < burnin < 1:
                  ist = int((1.-burnin)*len(v))
              else:
                  ist = int(burnin)
              plt.plot(n[ist:], v.iloc[:,i][ist:], alpha=0.75, color="C{}".format(j))
          if i != len(labels):
              plt.axhline(ref[i-1], color="gray", ls="--", lw=1)
          else:
              plt.legend(list(chains.keys()), loc="upper left", bbox_to_anchor=(1,1))
      plt.subplots_adjust(hspace=0.25, wspace=0.3)
#+END_SRC

** Understanding MCMC /à la/ cobaya
We run several MCMC for PxP survey (\ell 2; 3000) and *use the covariance matrix from Fisher*
calculation as input of =cobaya= MCMC algorithm. We check how the input covariance matrix changes the
MCMC convergence. Basically, we do the following tests:
- Covariance matrix/2
- Covariance matrix
- Covariance matrix*2
- Covariance matrix*4

#+BEGIN_SRC ipython :session bcv :results none
  labels = [r"$\theta_\mathrm{MC}$",
            r"$\log(10^{10}A_\mathrm{s})$",
            r"$n_\mathrm{s}$",
            r"$\Omega_\mathrm{b}h^2$",
            r"$\Omega_\mathrm{c}h^2$",
            r"$\chi^2-\chi^2_\mathrm{min}$",
            r"$A_\mathrm{s}$"]

  result_path=r"/home/garrido/Workdir/CMB/analysis/beyondCV/output/fisher"
#+END_SRC

*** Covariance matrix divide by 2
#+BEGIN_SRC ipython :session bcv :results raw drawer
  plot_chains(result_path + "/0.5/*_PxP_*/mcmc*.txt", burnin=0)
#+END_SRC

#+RESULTS:
:results:
# Out[58]:
[[file:./obipy-resources/KsgZNm.png]]
:end:

*** Initial covariance matrix
#+BEGIN_SRC ipython :session bcv :results raw drawer
  plot_chains(result_path + "/1/*_PxP_*/mcmc*.txt", burnin=0)
#+END_SRC

#+RESULTS:
:results:
# Out[57]:
[[file:./obipy-resources/mxPD8G.png]]
:end:

*** Covariance matrix multiply by 2
#+BEGIN_SRC ipython :session bcv :results raw drawer
  plot_chains(result_path + "/2/*_PxP_*/mcmc*.txt", burnin=0)
#+END_SRC

#+RESULTS:
:results:
# Out[56]:
[[file:./obipy-resources/xfa5zM.png]]
:end:

*** Covariance matrix multiply by 4
#+BEGIN_SRC ipython :session bcv :results raw drawer
  plot_chains(result_path + "/4/*_PxP_*/mcmc*.txt", burnin=0)
#+END_SRC

#+RESULTS:
:results:
# Out[9]:
[[file:./obipy-resources/VCVPbu.png]]
:end:

*** Remove =proposal_scale=
By default there is a =proposal_scale= parameter for =cobaya= MCMC which is set to 2.4. Here we set it
to 1 and check the results
#+BEGIN_SRC ipython :session bcv :results raw drawer
  plot_chains(result_path + "/no_proposal_scale/*_PxP_*/mcmc*.txt", burnin=0)
#+END_SRC

#+RESULTS:
:results:
# Out[55]:
[[file:./obipy-resources/PUylZd.png]]
:end:

*** Fix Χ²
Fix likelihood definition by adding a 1/2 factor
#+BEGIN_SRC ipython :session bcv :results raw drawer
  plot_chains(result_path + "/fix_chi2/*_PxP_*/mcmc*.txt", burnin=0)
#+END_SRC

#+RESULTS:
:results:
# Out[71]:
[[file:./obipy-resources/l91d5L.png]]
:end:

*** Plotting variances /vs./ Fisher results
#+BEGIN_SRC ipython :session bcv :results raw drawer
  fisher = np.array([5.126550726714351e-06, 0.006039315179940597, 0.005589724100405183, 0.00020382255228959761, 0.002334040314343254])
  def get_variance_ratio(scale_factor):
      mcmc = get_mcmc_variances(result_path + "/{}/*_PxP_*/mcmc*.txt".format(scale_factor))
      mcmc = np.mean(np.array(mcmc[:, 1:], dtype=np.float), axis=0)
      return fisher/mcmc

  def get_variance_from_covmat(scale_factor):
      all_files = glob.glob(result_path + "/{}/*/mcmc.covmat".format(scale_factor))
      variances = np.zeros((len(all_files), 5))
      for i, f in enumerate(all_files):
          cov = np.loadtxt(f)
          variances[i, :] = np.sqrt(np.diag(cov))
      return fisher/np.mean(variances, axis=1)

  x = np.arange(len(labels)-2)
  for scale in [0.5, 1, 2, 4]:
    plt.plot(x, get_variance_ratio(scale), "o", label="scale x{}".format(scale))
    # y = get_variance_from_covmat(scale)
    # print(y)
  plt.plot(x, get_variance_ratio("no_proposal_scale"), "o", label="no proposal scale".format(scale))
  plt.plot(x, get_variance_ratio("fix_chi2"), "o", label="fix chi2".format(scale))
  # plt.plot(x, get_variance_from_covmat("fich_chi2"), "s", label="fix chi2 (from covmat)")

  plt.axhline(1, color="gray", ls="--", lw=1)
  plt.ylabel(r"$\sigma$(Fisher)/$\sigma$(MCMC)")
  plt.xticks(x, labels[:-2])
  plt.legend(loc="upper left", bbox_to_anchor=(1,1))
#+END_SRC

#+RESULTS:
:results:
# Out[70]:
: <matplotlib.legend.Legend at 0x7f22e5f68400>
[[file:./obipy-resources/8ywhB4.png]]
:end:

** \Lambda CDM
*** Check chains
#+BEGIN_SRC ipython :session bcv :results none
  labels = [r"$\theta_\mathrm{MC}$",
            r"$\log(10^{10}A_\mathrm{s})$",
            r"$n_\mathrm{s}$",
            r"$\Omega_\mathrm{b}h^2$",
            r"$\Omega_\mathrm{c}h^2$",
            r"$\chi^2-\chi^2_\mathrm{min}$",
            r"$A_\mathrm{s}$"]

  result_path=r"/home/garrido/Workdir/CMB/analysis/beyondCV/output/lambda_cdm"
#+END_SRC

**** PxP
#+BEGIN_SRC ipython :session bcv :results raw drawer
  plot_chains(result_path + "/*_PxP_*/mcmc*.txt", burnin=0)
#+END_SRC

#+RESULTS:
:results:
# Out[340]:
[[file:./obipy-resources/PtN3XX.png]]
:end:

*** Triangle plot

#+BEGIN_SRC ipython :session bcv :results none
  def get_samples(path):
      chains = get_chains(path)
      key = next(iter(chains))
      samples = chains[key].iloc[:, 1:].values
      weights = chains[key].iloc[:, 0].values
      return samples, weights
#+END_SRC

#+BEGIN_SRC ipython :session bcv :results raw drawer
  samples = []
  surveys = ["PxP"]#, "SOxSO", "SOxP", "SOxSO-PxP", "SOxP-PxP", "SOxP-SOxSO"]
  for survey in surveys:
      for i in range(5):
          s, w = get_samples(result_path + "/*_{}_*{}/mcmc*.txt".format(survey, i))
          samples += [MCSamples(samples=s, names=labels, weights=w, ignore_rows=0.3)]

  g = plots.getSubplotPlotter()
  g.triangle_plot(samples, params=labels[:-2])
#+END_SRC

#+RESULTS:
:results:
# Out[242]:
[[file:./obipy-resources/CkHXrq.png]]
:end:

*** Plot variances from MCMC and Hessian
**** Compute standard deviation from MCMC
#+BEGIN_SRC ipython :session bcv :results none
  def get_mcmc_variances(path, burnin=0.3, keep_As=False):
      table = []
      lines = []
      all_files = glob.glob(path)
      if len(all_files) == 0:
        return np.array(table)
      all_files.sort()
      for f in all_files:
          samples, weights = get_samples(f)
          mcsamples = MCSamples(samples=samples, weights=weights, ignore_rows=burnin)
          sigmas = np.sqrt(mcsamples.getVars()).tolist()
          if keep_As:
              del sigmas[-2]
              table += [sigmas]
          else:
              table += [sigmas[:-2]]
          lines += [[f.split("/")[-2]]]
      table = np.append(lines, table, axis=1)
      return table
#+END_SRC

***** =org= table                                              :noexport:
#+BEGIN_SRC ipython :session bcv :results none
  table = get_mcmc_variances(result_path + "/results*/mcmc*.txt")
#+END_SRC
#+BEGIN_SRC ipython :session bcv :results raw output
  print(tabulate.tabulate(table, headers=labels[:-2], tablefmt="orgtbl"))
#+END_SRC

#+RESULTS:
|                          | $\theta_\mathrm{MC}$ | $\log(10^{10}A_\mathrm{s})$ | $n_\mathrm{s}$ | $\Omega_\mathrm{b}h^2$ | $\Omega_\mathrm{c}h^2$ |
|--------------------------+----------------------+-----------------------------+----------------+------------------------+------------------------|
| results_PxP_667_0        |          4.74425e-06 |                   0.0057473 |      0.0052601 |            0.000193577 |             0.00217759 |
| results_PxP_667_1        |          4.82155e-06 |                  0.00574706 |     0.00539517 |            0.000194073 |             0.00220569 |
| results_PxP_667_2        |          5.21727e-06 |                  0.00588659 |     0.00577756 |            0.000194396 |             0.00219697 |
| results_PxP_667_3        |          4.87957e-06 |                  0.00584553 |     0.00551065 |            0.000177916 |             0.00223142 |
| results_PxP_667_4        |           5.2497e-06 |                  0.00609538 |     0.00577003 |            0.000227061 |             0.00241091 |
| results_SOxP-PxP_667_0   |          5.97218e-07 |                 0.000572401 |    0.000664856 |            2.37293e-05 |            0.000237613 |
| results_SOxP-PxP_667_1   |          5.86433e-06 |                   0.0033117 |     0.00372901 |            0.000327235 |             0.00102174 |
| results_SOxP-PxP_667_2   |          5.62752e-07 |                  0.00048048 |    0.000619475 |            2.09465e-05 |            0.000190906 |
| results_SOxP-PxP_667_3   |          6.75453e-07 |                 0.000594023 |    0.000764447 |            2.28355e-05 |            0.000237303 |
| results_SOxP-PxP_667_4   |          1.92234e-06 |                  0.00333287 |     0.00331181 |            0.000117523 |             0.00160005 |
| results_SOxP-SOxSO_667_0 |           7.0684e-07 |                 0.000635875 |    0.000750761 |            2.23252e-05 |            0.000251479 |
| results_SOxP-SOxSO_667_1 |          2.54656e-06 |                  0.00324051 |     0.00474923 |             0.00023869 |            0.000607815 |
| results_SOxP-SOxSO_667_2 |          5.85205e-07 |                 0.000571013 |    0.000684214 |            1.92067e-05 |            0.000229032 |
| results_SOxP-SOxSO_667_3 |          5.81253e-07 |                  0.00158462 |     0.00171999 |            3.69325e-05 |             0.00069581 |
| results_SOxP-SOxSO_667_4 |          2.18445e-06 |                  0.00527362 |     0.00327569 |            9.21607e-05 |             0.00272104 |
| results_SOxSO-PxP_667_0  |          1.08559e-06 |                 0.000941411 |     0.00123661 |            3.88313e-05 |            0.000389722 |
| results_SOxSO-PxP_667_1  |          1.63874e-06 |                  0.00145313 |     0.00203199 |            7.77133e-05 |            0.000504334 |
| results_SOxSO-PxP_667_2  |          1.27069e-06 |                  0.00111489 |     0.00132153 |            4.33265e-05 |            0.000451924 |
| results_SOxSO-PxP_667_3  |          1.16467e-06 |                  0.00112296 |     0.00136685 |            4.34647e-05 |            0.000454294 |
| results_SOxSO-PxP_667_4  |          9.84448e-07 |                 0.000905686 |     0.00109324 |            3.58838e-05 |            0.000382165 |
| results_SOxSO_667_0      |          2.75347e-06 |                  0.00431607 |     0.00425779 |            0.000124171 |             0.00157076 |

**** Compare MCMC to minimization and Fisher                  :deprecated:
| PxP                             | $\theta_\mathrm{MC}$ | $A_\mathrm{s}$ | $n_\mathrm{s}$ | $\Omega_\mathrm{b}h^2$ | $\Omega_\mathrm{c}h^2$ |
|---------------------------------+----------------------+----------------+----------------+------------------------+------------------------|
| $\sigma$ (Minimization)         |          4.99937e-06 |    1.24047e-11 |     0.00544548 |            0.000206822 |              0.0022281 |
| $\sigma$ (Minimization 2;3000)  |          4.88563e-06 |    1.22407e-11 |     0.00529792 |            0.000204028 |              0.0022389 |
| $\sigma$ (Fisher)               |          5.12655e-06 |    1.28546e-11 |     0.00558972 |            0.000203823 |             0.00233404 |
| $\sigma$ (MCMC)                 |          3.60082e-06 |    0.89984e-11 |     0.00394778 |            0.000143322 |             0.00162962 |
| $\Delta\sigma$ (min-Fisher) [%] |             -2.48081 |        -3.5002 |       -2.58047 |                1.47141 |                -4.5391 |
|---------------------------------+----------------------+----------------+----------------+------------------------+------------------------|
| SOxSO                           | $\theta_\mathrm{MC}$ | $A_\mathrm{s}$ | $n_\mathrm{s}$ | $\Omega_\mathrm{b}h^2$ | $\Omega_\mathrm{c}h^2$ |
|---------------------------------+----------------------+----------------+----------------+------------------------+------------------------|
| $\sigma$ (Minimization)         |          3.30158e-06 |    8.82142e-12 |     0.00403527 |            0.000113061 |             0.00147556 |
| $\sigma$ (Fisher)               |          3.31809e-06 |    9.02724e-12 |     0.00410550 |            0.000112680 |             0.00148535 |
|---------------------------------+----------------------+----------------+----------------+------------------------+------------------------|
| SOxP                            | $\theta_\mathrm{MC}$ | $A_\mathrm{s}$ | $n_\mathrm{s}$ | $\Omega_\mathrm{b}h^2$ | $\Omega_\mathrm{c}h^2$ |
|---------------------------------+----------------------+----------------+----------------+------------------------+------------------------|
| $\sigma$ (Minimization)         |          4.13856e-06 |    1.10042e-11 |      0.0048009 |            0.000153239 |             0.00196259 |
| $\sigma$ (Fisher)               |          4.20292e-06 |    1.13107e-11 |      0.0049306 |            0.000153280 |             0.00199297 |


#+BEGIN_SRC ipython :session bcv :results raw drawer
  for i in np.arange(0, 0.7, 0.1):
      mcmc = get_mcmc_variances(result_path + "/results*_PxP_*[0-4]/mcmc*.txt", keep_As=True, burnin=i)
      mcmc = np.mean(np.array(mcmc[:, 1:], dtype=np.float), axis=0)
      mcmc[1] = mcmc[-1] # Use As for comparison
      plt.plot(ref_std[:-1]/mcmc[:-1], "o", label="burnin {:.1f}".format(i))

  plt.ylabel(r"$\sigma$(Fisher)/$\sigma$(MCMC)$")
  xlabels = [r"$\theta_\mathrm{MC}$",
            r"$A_\mathrm{s}$",
            r"$n_\mathrm{s}$",
            r"$\Omega_\mathrm{b}h^2$",
            r"$\Omega_\mathrm{c}h^2$"]
  plt.xticks(np.arange(len(xlabels)), xlabels)
  plt.legend(loc="upper left", bbox_to_anchor=(1,1))
#+END_SRC

#+RESULTS:
:results:
# Out[1084]:
: <matplotlib.legend.Legend at 0x7fcbe5fb1198>
[[file:./obipy-resources/7t1JvP.png]]
:end:

**** From Hessian                                             :deprecated:
#+BEGIN_SRC ipython :session bcv :results none
  import pickle
  def get_hessians(f):
      d = pickle.load(open(f, "rb"))
      # except:
      #     print("Fail to open {}".format(f))
      #     pass
      hess = d["results"]["OptimizeResult"]["hess_inv"]
      return np.sqrt(np.diagonal(hess))

  def get_hessians_table(path):
      table = []
      lines = []
      files = glob.glob(path)
      files.sort()
      for f in files:
          table += [get_hessians(f).tolist()]
          lines += [[f.split("/")[-2]]]

      table = np.append(lines, table, axis=1)
      return table
#+END_SRC

#+BEGIN_SRC ipython :session bcv :results none
  table = get_hessians_table(result_path + "/output*/min*.pkl")
  display(HTML(tabulate.tabulate(table, headers=labels[:-2], tablefmt="html")))
#+END_SRC

***** =org= table                                              :noexport:
#+BEGIN_SRC ipython :session bcv :results raw output
  print(tabulate.tabulate(table, headers=labels[:-2], tablefmt="orgtbl"))
#+END_SRC

#+RESULTS:
|                     |   $\theta_\mathrm{MC}$ | $\log(10^{10}A_\mathrm{s})$ |        $n_\mathrm{s}$ | $\Omega_\mathrm{b}h^2$ | $\Omega_\mathrm{c}h^2$ |
|---------------------+------------------------+-----------------------------+-----------------------+------------------------+------------------------|
| output_SOxP-PxP_3   |            1.27285e-06 |                  0.00151253 |           0.000335953 |            9.12838e-05 |            2.48647e-05 |
| output_SOxP-PxP_4   |            5.11765e-07 |                 0.000347024 |           0.000504766 |            1.63855e-05 |            0.000153263 |
| output_SOxP-SOxSO_0 |            5.22319e-07 |                 0.000321383 |           0.000467955 |            7.77545e-06 |            0.000144856 |
| output_SOxP-SOxSO_1 |             1.1058e-07 |                  0.00158029 |           0.000242349 |            9.15489e-05 |             2.5819e-05 |
| output_SOxP-SOxSO_2 |            4.68394e-07 |                 0.000332471 |           0.000446926 |            7.51214e-06 |            0.000141894 |
| output_SOxSO-PxP_0  |            9.07562e-07 |                 0.000462882 |           0.000710933 |            2.45234e-05 |            0.000173289 |
| output_SOxSO-PxP_1  |            1.00649e-06 |                  0.00234359 |           0.000727028 |            0.000117997 |            0.000562889 |
| output_SOxSO-PxP_3  |            1.04358e-06 |                 0.000916334 |            0.00126595 |            3.51463e-05 |            0.000428267 |
| output_SOxSO-PxP_4  |            1.09634e-06 |                 0.000803228 |            0.00118938 |            3.60983e-05 |            0.000384808 |
**** Summary
#+BEGIN_SRC ipython :session bcv :results raw drawer :var min_l_2_3000=min_l_2_3000 :var min_l_50_2000=min_l_50_2000 :var min_l_50_1500=min_l_50_1500
  mcmc = {}
  surveys = ["PxP", "SOxSO-PxP", "SOxP-PxP", "SOxP-SOxSO"]
  for survey in surveys:
      mcmc_var = get_mcmc_variances(result_path + "/results*_{}_*/mcmc*.txt".format(survey), burnin=0.3, keep_As=True)
      if mcmc_var.size != 0:
          mcmc_var = np.mean(np.array(mcmc_var[:, 1:], dtype=np.float), axis=0)
          # Use As
          mcmc_var[1] = mcmc_var[-1]; mcmc_var = mcmc_var[:-1]
          mcmc[survey] = mcmc_var
  fig, ax = plt.subplots(1, len(surveys)-1, sharex="col", sharey="row", figsize=(15, 5))
  xlabels = [r"$\theta_\mathrm{MC}$",
             r"$A_\mathrm{s}$",
             r"$n_\mathrm{s}$",
             r"$\Omega_\mathrm{b}h^2$",
             r"$\Omega_\mathrm{c}h^2$"]
  x = np.arange(len(xlabels))
  for i, survey in enumerate(surveys[1:]):
      ax[i].plot(x, mcmc["PxP"]/mcmc[survey], "o")
      ax[i].set_title(survey)
      ax[i].set_xticks(x)
      ax[i].set_xticklabels(xlabels)

  ax[0].set_ylabel(r"$\sigma{\rm(residuals)}/\sigma{\rm(Planck)}$", fontsize=14)
  plt.subplots_adjust(wspace=0.1)

  mini = {}
  mini["SOxSO-PxP"] = [min_l_2_3000[6][1:-1], min_l_50_2000[6][1:-1], min_l_50_1500[6][1:-1]]
  mini["SOxP-SOxSO"] = [min_l_2_3000[7][1:-1], min_l_50_2000[7][1:-1], min_l_50_1500[7][1:-1]]
  for i in mini["SOxSO-PxP"]:
      ax[0].plot(x, mcmc["PxP"]/np.array(i, dtype=np.float), "o")
  for i in mini["SOxP-SOxSO"]:
      ax[2].plot(x, mcmc["PxP"]/np.array(i, dtype=np.float), "o")

  ax[2].legend(["MCMC",
                r"Minimization $\ell\in[2;3000]$",
                r"Minimization $\ell\in[50;2000]$",
                r"Minimization $\ell\in[50;1500]$"],
               loc="upper left", bbox_to_anchor=(1,1))

#+END_SRC

#+RESULTS:
:resu!lts:
# Out[354]:
: <matplotlib.legend.Legend at 0x7f22de74b780>
[[file:./obipy-resources/UTmCrn.png]]
:end:
** \Lambda CDM + ALens
#+BEGIN_SRC ipython :session bcv :results none
  labels = [r"$\theta_\mathrm{MC}$",
            r"$\log(10^{10}A_\mathrm{s})$",
            r"$n_\mathrm{s}$",
            r"$\Omega_\mathrm{b}h^2$",
            r"$\Omega_\mathrm{c}h^2$",
            r"$\mathrm{A}_\mathrm{L}$",
            r"$\chi^2-\chi^2_\mathrm{min}$",
            r"$A_\mathrm{s}$"]

  result_path = r"/home/garrido/Workdir/CMB/analysis/beyondCV/output/ALens"
#+END_SRC

*** Check minimization                                         :deprecated:
Get Hessians from minimizations
#+BEGIN_SRC ipython :session bcv :results raw output
  def check_minimization(path):
      all_files = glob.glob(path)
      all_files.sort()
      table = []
      for f in all_files:
          import pickle
          opt_result =  pickle.load(open(f, "rb"))["results"]["OptimizeResult"]
          msg = opt_result.get("message")
          ntry = opt_result.get("ntry")
          proposal = np.sqrt(np.diag(opt_result.get("hess_inv")))
          table += [[f.split("/")[-2], msg, ntry, *proposal]]
      return table

  headers = ["" for i in range(len(table))]
  headers[0:3] = ["Directory", "Status", "ntry"]
  table = check_minimization(result_path + "/results_*/min*.pkl")
  print(tabulate.tabulate(table, headers=headers, tablefmt="orgtbl"))
#+END_SRC

#+RESULTS:
| Directory                | Status                                                        | ntry |             |             |             |             |             |            |
|--------------------------+---------------------------------------------------------------+------+-------------+-------------+-------------+-------------+-------------+------------|
| results_PxP_666_0        | Optimization terminated successfully.                         |    1 | 2.45279e-06 |  0.00127271 |  0.00173696 | 1.92859e-05 | 0.000102676 |  0.0371089 |
| results_PxP_666_1        | Optimization terminated successfully.                         |    3 | 2.51867e-06 |  0.00127433 |  0.00174105 | 1.98167e-05 | 0.000104576 |  0.0372196 |
| results_PxP_666_2        | Optimization failed. Estimated distance to minimum too large. |   10 | 7.88674e-06 |   0.0054606 |  0.00336989 | 0.000469289 |  0.00161214 |  0.0321427 |
| results_PxP_666_3        | Optimization terminated successfully.                         |    2 | 1.56056e-06 |  0.00124956 |  0.00186414 | 7.75352e-08 | 1.32847e-06 |   0.037062 |
| results_PxP_666_4        | Optimization failed. Estimated distance to minimum too large. |   10 | 8.69136e-06 |  0.00701867 |  0.00145824 | 0.000264677 |  0.00175731 |  0.0335381 |
| results_SOxP-PxP_666_0   | Optimization failed. Estimated distance to minimum too large. |   10 | 9.22459e-07 |  0.00104732 | 0.000564614 | 5.04288e-05 | 0.000201154 | 0.00714164 |
| results_SOxP-PxP_666_1   | Optimization terminated successfully.                         |   10 |  9.0337e-08 | 2.84498e-05 | 5.98497e-05 |  1.5575e-06 | 0.000191972 | 0.00193414 |
| results_SOxP-PxP_666_2   | Optimization failed. Estimated distance to minimum too large. |   10 | 9.57402e-07 |  0.00105051 | 0.000581368 |  5.4242e-05 | 0.000203156 | 0.00703166 |
| results_SOxP-PxP_666_3   | Optimization terminated successfully.                         |    3 | 1.96339e-09 | 0.000126758 | 0.000263662 | 2.40126e-08 | 4.72171e-07 | 0.00915843 |
| results_SOxP-PxP_666_4   | Optimization terminated successfully.                         |    5 |         nan | 0.000131209 | 0.000245221 | 1.65014e-08 | 8.61895e-08 | 0.00836779 |
| results_SOxP-SOxSO_666_0 | Optimization failed. Estimated distance to minimum too large. |   10 | 2.12856e-05 |    0.043254 |   0.0928904 |   0.0030256 |   0.0276215 |   0.499861 |
| results_SOxP-SOxSO_666_1 | Optimization failed. Estimated distance to minimum too large. |   10 | 9.34821e-07 |  0.00101484 | 0.000580833 | 5.28625e-05 | 0.000201045 | 0.00599991 |
| results_SOxP-SOxSO_666_2 | Optimization failed. Estimated distance to minimum too large. |   10 | 9.20422e-07 |  0.00101758 | 0.000576264 | 5.11041e-05 | 0.000201932 | 0.00604622 |
| results_SOxP-SOxSO_666_3 | Optimization terminated successfully.                         |    9 | 3.68883e-07 | 0.000191872 | 0.000375334 | 1.20329e-05 | 9.44402e-05 | 0.00892633 |
| results_SOxP-SOxSO_666_4 | Optimization failed. Estimated distance to minimum too large. |   10 | 9.46696e-07 |  0.00101196 |  0.00057742 | 5.32062e-05 | 0.000200988 | 0.00596027 |
| results_SOxSO-PxP_666_0  | Optimization terminated successfully.                         |    3 | 3.75123e-08 | 0.000253156 | 0.000544788 | 2.39345e-07 | 2.75641e-06 |  0.0181562 |
| results_SOxSO-PxP_666_1  | Optimization terminated successfully.                         |    1 | 9.69176e-11 | 0.000255144 | 0.000542427 | 2.53447e-09 | 4.46759e-07 |  0.0164859 |
| results_SOxSO-PxP_666_2  | Optimization terminated successfully.                         |    2 | 1.06214e-06 |  0.00136352 |  0.00130783 | 3.26274e-05 | 0.000510877 |  0.0188921 |
| results_SOxSO-PxP_666_3  | Optimization terminated successfully.                         |    4 | 9.82267e-07 | 0.000595596 | 0.000927502 |  3.1446e-05 | 0.000270605 |  0.0188644 |
| results_SOxSO-PxP_666_4  | Optimization terminated successfully.                         |    2 | 3.05605e-10 | 0.000254057 | 0.000538275 | 1.82764e-08 |  1.3862e-06 |  0.0192113 |

*** Check chains
**** PxP
#+BEGIN_SRC ipython :session bcv :results raw drawer
  plot_chains(result_path + "/*_PxP_*/mcmc*.txt", burnin=0, labels=labels)
#+END_SRC

#+RESULTS:
:results:
# Out[444]:
[[file:./obipy-resources/pFHe0D.png]]
:end:

**** SOxSO
#+BEGIN_SRC ipython :session bcv :results raw drawer
  plot_chains(result_path + "/*_SOxSO_*/mcmc*.txt", burnin=0, labels=labels)
#+END_SRC

#+RESULTS:
:results:
# Out[229]:
[[file:./obipy-resources/guaAFa.png]]
:end:

**** SOxP
#+BEGIN_SRC ipython :session bcv :results raw drawer
  plot_chains(result_path + "/*_SOxP_*/mcmc*.txt", burnin=0, labels=labels)
#+END_SRC

#+RESULTS:
:results:
# Out[246]:
[[file:./obipy-resources/4P2ryo.png]]
:end:

**** SOxSO - PxP
#+BEGIN_SRC ipython :session bcv :results raw drawer
  plot_chains(result_path + "/*_SOxSO-PxP_*/mcmc*.txt", burnin=0.5, labels=labels)
#+END_SRC

#+RESULTS:
:results:
# Out[449]:
[[file:./obipy-resources/pWuCYN.png]]
:end:

**** SOxP - PxP
#+BEGIN_SRC ipython :session bcv :results raw drawer
  plot_chains(result_path + "/*_SOxP-PxP*/mcmc*.txt", burnin=0.5, labels=labels)
#+END_SRC

#+RESULTS:
:results:
# Out[448]:
[[file:./obipy-resources/BeJ5Ax.png]]
:end:

**** SOxP - SOxSO
#+BEGIN_SRC ipython :session bcv :results raw drawer
  plot_chains(result_path + "/*_SOxP-SOxSO*/mcmc*.txt", burnin=0, labels=labels)
#+END_SRC

#+RESULTS:
:results:
# Out[447]:
[[file:./obipy-resources/c0KVYF.png]]
:end:

*** Triangle plot
#+BEGIN_SRC ipython :session bcv :results none
  def plot_samples(path, burnin=0.3, colors=None, scale=None, delta=False, labels=None, renames=None, legend=None):
      samples = []
      the_colors = []
      all_files = []
      if isinstance(path, list):
          for p in path:
              all_files.extend(glob.glob(p))
      else:
          all_files = glob.glob(path)
          all_files.sort()
      for f in all_files:
          s, w = get_samples(f)
          s = s[:, :-2]
          if scale:
              renorm = np.array(scale)/(w.dot(s)/np.sum(w))
              s *= renorm
          if delta:
              s -= np.mean(s, axis=0)
          survey = f.split("/")[-2]
          i = survey.split("_")[-1]
          survey = survey.split("_")[1]
          samples += [MCSamples(samples=s, names=labels[:-2], label="{} - MCMC {}".format(survey, i), weights=w, ignore_rows=burnin)]
          the_colors += ["-C{}".format(i)]

      g = plots.getSubplotPlotter()
      g.settings.lineM = colors if colors else the_colors
      if legend:
          g.triangle_plot(samples, params=labels[:-2], legend_labels=[])
          g.add_legend(legend, colored_text=True, figure=True, align_right=True)
      else:
          g.triangle_plot(samples, params=labels[:-2])
      return g
#+END_SRC

#+BEGIN_SRC ipython :session bcv :results raw drawer
  ref = [1.04164/100, 3.058, 0.9649, 0.02212, 0.1210, 1]
  mcmc_survey= ["PxP", "SOxSO", "SOxSO-PxP", "SOxP-PxP", "SOxP-SOxSO"]
  mcmc_nbr = ["2"]
  paths = []
  for f in mcmc_survey:
    for g in mcmc_nbr:
      paths += [result_path + "/*_{}_*{}/mcmc*.txt".format(f,g)]
  colors = []
  for i,_ in enumerate(mcmc_survey):
      colors += len(mcmc_nbr)*["-C{}".format(i)]
  plot_samples(path=paths, burnin=0.5, scale=ref, colors=colors, legend=mcmc_survey, labels=labels)
#+END_SRC

#+RESULTS:
:results:
# Out[589]:
: <getdist.plots.GetDistPlotter at 0x7f22d6f1beb8>
[[file:./obipy-resources/Lflb1w.png]]
:end:

*** Plot variances from MCMC
#+BEGIN_SRC ipython :session bcv :results raw drawer
  use_As = False
  mcmc_nbr = ["2"]
  mcmc = {}
  surveys = ["PxP", "SOxSO", "SOxSO-PxP", "SOxP-PxP", "SOxP-SOxSO"]
  for survey in surveys:
      mcmc_var = get_mcmc_variances(result_path + "/results*_{}_*{}/mcmc*.txt".format(survey, ",".join(mcmc_nbr)), burnin=0.3, keep_As=use_As)
      if mcmc_var.size != 0:
          mcmc_var = np.mean(np.array(mcmc_var[:, 1:], dtype=np.float), axis=0)
          if use_As:
              # Use As
              mcmc_var[1] = mcmc_var[-1]; mcmc_var = mcmc_var[:-1]
          mcmc[survey] = mcmc_var
  xlabels = [r"$\theta_\mathrm{MC}$",
             r"$\log(10^{10}A_\mathrm{s})$",
             r"$n_\mathrm{s}$",
             r"$\Omega_\mathrm{b}h^2$",
             r"$\Omega_\mathrm{c}h^2$",
            r"$\mathrm{A}_\mathrm{L}$"]
  if use_As:
      xlabels[1] = r"$A_\mathrm{s}$"
  x = np.arange(len(xlabels))
  for i, survey in enumerate(surveys):
      y = mcmc["PxP"]/mcmc[survey]
      plt.plot(x, y, "o", label=survey, color="C{}".format(i))
      plt.axhline(np.mean(y), color="C{}".format(i), ls="--", lw=1)

  fisher = np.array([5.488784226430075e-06, 0.006886322958075309, 0.006082145093362834, 0.00022563053346601842, 0.0027330648180420945, 0.07145648912030945])
  plt.plot(x, mcmc["PxP"]/fisher, "ok", label="fisher")
  plt.xticks(x, xlabels)
  plt.ylabel(r"$\sigma{\rm(residuals)}/\sigma{\rm(Planck)}$", fontsize=14)
  plt.ylim(0,)
  leg = plt.legend(loc="upper left", bbox_to_anchor=(1,1))
  for i, text in enumerate(leg.get_texts()[:-1]):
      text.set_color("C{}".format(i))
#+END_SRC

#+RESULTS:
:results:
# Out[585]:
[[file:./obipy-resources/pv7Npe.png]]
:end:

** \Lambda CDM + H0
#+BEGIN_SRC ipython :session :results none
  labels = [r"$H_0$",
            r"$\log(10^{10}A_\mathrm{s})$",
            r"$n_\mathrm{s}$",
            r"$\Omega_\mathrm{b}h^2$",
            r"$\Omega_\mathrm{c}h^2$",
            r"$\mathrm{A}_\mathrm{L}$",
            r"$\chi^2-\chi^2_\mathrm{min}$",
            r"$A_\mathrm{s}$"]

  result_path = r"/home/garrido/Workdir/CMB/analysis/beyondCV/output/H0"
#+END_SRC

*** Check chains
**** PxP
#+BEGIN_SRC ipython :session bcv :results raw drawer
  plot_chains(result_path + "/*_PxP_*/mcmc*.txt", burnin=0, labels=labels)
#+END_SRC

#+RESULTS:
:results:
# Out[50]:
[[file:./obipy-resources/7FZWZg.png]]
:end:

**** SOxSO
#+BEGIN_SRC ipython :session bcv :results raw drawer
  plot_chains(result_path + "/*_SOxSO_*/mcmc*.txt", burnin=0, labels=labels)
#+END_SRC

#+RESULTS:
:results:
# Out[51]:
[[file:./obipy-resources/ntKLG2.png]]
:end:

**** SOxP
#+BEGIN_SRC ipython :session bcv :results raw drawer
  plot_chains(result_path + "/*_SOxP_*/mcmc*.txt", burnin=0, labels=labels)
#+END_SRC

#+RESULTS:
:results:
# Out[52]:
[[file:./obipy-resources/N2gQpa.png]]
:end:

**** SOxSO - PxP
#+BEGIN_SRC ipython :session bcv :results raw drawer
  plot_chains(result_path + "/*_SOxSO-PxP_*/mcmc*.txt", burnin=0, labels=labels)
#+END_SRC

#+RESULTS:
:results:
# Out[53]:
[[file:./obipy-resources/laW1CF.png]]
:end:

**** SOxP - PxP
#+BEGIN_SRC ipython :session bcv :results raw drawer
  plot_chains(result_path + "/*_SOxP-PxP*/mcmc*.txt", burnin=0, labels=labels)
#+END_SRC

#+RESULTS:
:results:
# Out[54]:
[[file:./obipy-resources/xq6omq.png]]
:end:

**** SOxP - SOxSO
#+BEGIN_SRC ipython :session bcv :results raw drawer
  plot_chains(result_path + "/*_SOxP-SOxSO*/mcmc*.txt", burnin=0, labels=labels)
#+END_SRC

#+RESULTS:
:results:
# Out[55]:
[[file:./obipy-resources/vNl2Lw.png]]
:end:
**** SOxSO + PxP - 2SOxP
#+BEGIN_SRC ipython :session bcv :results raw drawer
  plot_chains(result_path + "/*_SOxSO+PxP-2SOxP_*/mcmc*.txt", burnin=0.3, labels=labels)
#+END_SRC

#+RESULTS:
:results:
# Out[18]:
[[file:./obipy-resources/T82cB5.png]]
:end:

** \Lambda CDM + ALens + H0 derived from \theta_{MC}
#+BEGIN_SRC ipython :session :results none
  labels = [
    r"$\theta_\mathrm{MC}$",
    r"$\log(10^{10}A_\mathrm{s})$",
    r"$n_\mathrm{s}$",
    r"$\Omega_\mathrm{b}h^2$",
    r"$\Omega_\mathrm{c}h^2$",
    r"$\mathrm{A}_\mathrm{L}$",
    # r"$A_S$",
    r"$H_0$",
    r"$\chi^2-\chi^2_\mathrm{min}$"]

  result_path = r"/home/garrido/Workdir/CMB/analysis/beyondCV/output/mcmc_derived_H0"
#+END_SRC
*** Check chains
**** PxP
#+BEGIN_SRC ipython :session :results raw drawer
  plot_chains(result_path + "/*_PxP_*/mcmc*.txt", burnin=0, labels=labels)
#+END_SRC

#+RESULTS:
:results:
# Out[81]:
[[file:./obipy-resources/ax20fh.png]]
:end:
**** SOxSO
#+BEGIN_SRC ipython :session :results raw drawer
  plot_chains(result_path + "/*_SOxSO_*/mcmc*.txt", burnin=0, labels=labels)
#+END_SRC

#+RESULTS:
:results:
# Out[82]:
[[file:./obipy-resources/SX1zBy.png]]
:end:

**** SOxP
#+BEGIN_SRC ipython :session :results raw drawer
  plot_chains(result_path + "/*_SOxP_*/mcmc*.txt", burnin=0, labels=labels)
#+END_SRC

#+RESULTS:
:results:
# Out[83]:
[[file:./obipy-resources/Ok4jHj.png]]
:end:

**** SOxSO - PxP
#+BEGIN_SRC ipython :session :results raw drawer
  plot_chains(result_path + "/*_SOxSO-PxP_*/mcmc*.txt", burnin=0, labels=labels)
#+END_SRC

#+RESULTS:
:results:
# Out[84]:
[[file:./obipy-resources/Noyq7R.png]]
:end:

**** SOxP - PxP
#+BEGIN_SRC ipython :session :results raw drawer
  plot_chains(result_path + "/*_SOxP-PxP_*/mcmc*.txt", burnin=0, labels=labels)
#+END_SRC

#+RESULTS:
:results:
# Out[85]:
[[file:./obipy-resources/CjFP4N.png]]
:end:

**** SOxP - SOxSO
#+BEGIN_SRC ipython :session :results raw drawer
  plot_chains(result_path + "/*_SOxP-SOxSO_*/mcmc*.txt", burnin=0, labels=labels)
#+END_SRC

#+RESULTS:
:results:
# Out[86]:
[[file:./obipy-resources/MpMnLM.png]]
:end:

**** SOxSO + PxP -2SOxP
#+BEGIN_SRC ipython :session :results raw drawer
  plot_chains(result_path + "/*_SOxSO+PxP-2SOxP_*/mcmc*.txt", burnin=0, labels=labels)
#+END_SRC

#+RESULTS:
:results:
# Out[87]:
[[file:./obipy-resources/P6nGlb.png]]
:end:

* Comparison with Planck 2018 results

#+BEGIN_SRC ipython :session :results raw drawer
  from getdist import loadMCSamples, plots, MCSamples

  def get_mean_diffs(path, cols):
      # Variable names
      renames = [r"$\Delta{}H_0~[\textrm{km/s}]$",
                 # r"$\log(10^{10}A_\mathrm{s})$",
                 r"$\Delta{}n_\mathrm{s}$",
                 r"$\Delta\Omega_\mathrm{b}h^2$",
                 r"$\Delta\Omega_\mathrm{c}h^2$",
                 r"$\Delta\mathrm{A}_\mathrm{L}$"]
      # Load MC Samples
      tmp = loadMCSamples(path, no_cache=True, settings={"ignore_rows": 0.4})

      # Get mean diffs as arrays
      mean_diffs = tmp.mean_diffs()

      # Keep only interesting columns i.e. cosmo; parameters
      mean_diffs = [mean_diffs[i] for i in cols]
      return MCSamples(samples=mean_diffs, names=renames)


  output_path = r"/home/garrido/Workdir/CMB/analysis/beyondCV/output"

  # Planck 2018
  path = output_path + r"/COM_CosmoParams_fullGrid_R3.00/base_Alens/plikHM_TT_lowl_lowE/base_Alens_plikHM_TT_lowl_lowE"
  # cols = [22, 5, 6, 0, 1, 4]
  cols = [22, 6, 0, 1, 4]
  samples = [get_mean_diffs(path, cols)]

  # BeyondCV output
  mcmc_survey= {"PxP"             : 2,
                "SOxSO"           : 2,
                "SOxSO-PxP"       : 3,
                "SOxP-PxP"        : 4,
                "SOxP-SOxSO"      : 2,
                "SOxSO+PxP-2SOxP" : 4}
  cols = [7, 2, 3, 4, 5]
  for survey, chain in mcmc_survey.items():
      path = output_path + r"/mcmc_derived_H0/results_{}_666_{}/mcmc".format(survey, chain)
      samples += [get_mean_diffs(path, cols)]

  g = plots.getSubplotPlotter()
  g.settings.lineM = ["--gray"] + ["-C{}".format(i) for i in range(10)]
  g.triangle_plot(samples, legend_labels=[])
  g.add_legend(["Planck 2018"] + list(mcmc_survey.keys()), colored_text=True, figure=True, align_right=True)
  #  g.export("triangle_plot.pdf")
#+END_SRC

#+RESULTS:
:results:
# Out[90]:
: <matplotlib.legend.Legend at 0x7fc1e0be0898>
[[file:./obipy-resources/rLIRFD.png]]
:end:

#+BEGIN_SRC ipython :session :results raw drawer
  import numpy as np
  from getdist import loadMCSamples

  # Variable names
  xlabels = [r"$H_0$",
             r"$\log(10^{10}A_\mathrm{s})$",
             r"$n_\mathrm{s}$",
             r"$\Omega_\mathrm{b}h^2$",
             r"$\Omega_\mathrm{c}h^2$",
             r"$\mathrm{A}_\mathrm{L}$"]

  output_path = r"/home/garrido/Workdir/CMB/analysis/beyondCV/output"

  # Planck 2018
  path = output_path + r"/COM_CosmoParams_fullGrid_R3.00/base_Alens/plikHM_TT_lowl_lowE/base_Alens_plikHM_TT_lowl_lowE"
  cols = [22, 5, 6, 0, 1, 4]
  planck2018 = np.array([loadMCSamples(path).getVars()[i] for i in cols])

  # BeyondCV output
  surveys = ["PxP", "SOxSO", "SOxSO-PxP", "SOxP-PxP", "SOxP-SOxSO", "SOxSO+PxP-2SOxP"]
  cols = [7, 1, 2, 3, 4, 5]
  x = np.arange(len(xlabels))
  for s, survey in enumerate(surveys):
      path = output_path + r"/mcmc_derived_H0/results_{}_666_{}/mcmc".format(survey, mcmc_survey[survey])
      a = np.array([loadMCSamples(path, settings={"ignore_rows": 0.4}).getVars()[i] for i in cols])
      if s == 0:
          pxp = planck2018 #a
      y = np.sqrt(pxp/a)
      print(survey, np.sqrt(a))
      plt.plot(x, y, "o", label=survey, color="C{}".format(s))
      # plt.axhline(np.mean(y), color="C{}".format(s), ls="--", lw=1)

  plt.xticks(x, xlabels)
  plt.ylabel(r"$\sigma{\rm (Planck 2018)}/\sigma{\rm (residuals)}$")
  #plt.ylim(0,15)
  leg = plt.legend(loc="upper left", bbox_to_anchor=(1,1))
  for i, text in enumerate(leg.get_texts()):
    text.set_color("C{}".format(i))
#+END_SRC

#+RESULTS:
:results:
# Out[102]:
[[file:./obipy-resources/L1O3bH.png]]
:end:

|-----------------+-------------+----------------+-------------+-------------+-------------+-------------|
|                 |          H0 | log(10^{10}As) |          ns |    \omega_b |    \omega_c |          AL |
|-----------------+-------------+----------------+-------------+-------------+-------------+-------------|
| PxP             |  0.93255402 |     2.49066446 |  1.05577509 |  1.15234731 |  0.86194105 |  1.17551905 |
| SOxSO           |  1.05281827 |     2.72998524 |  1.19484862 |  1.34476173 |    0.959298 |  1.44858526 |
| SOxSO-PxP       |  4.57605924 |     14.0318481 |  4.37597586 |   5.0700229 |  4.54500663 |   4.2443415 |
| SOxP-PxP        |  8.79996857 |    26.85164185 |  8.09104811 |      9.6115 |  8.78887334 |  8.13562102 |
| SOxP-SOxSO      |   9.3887416 |    28.01967011 |  8.94262101 | 10.63241334 |  9.24735455 |  9.20433168 |
| SOxSO+PxP-2SOxP | 33.34609892 |    121.0552643 | 27.33891935 | 36.29531562 | 35.45656894 | 32.63120982 |


|-----------------+----------------+----------------+----------------+----------------+----------------+----------------|
|                 |             H0 |             ns | log(10^{10}As) |       \omega_b |       \omega_c |             AL |
|-----------------+----------------+----------------+----------------+----------------+----------------+----------------|
| Planck 2018     | 1.18658546e+00 | 1.81103635e-02 | 7.06064590e-03 | 2.89176738e-04 | 2.46748133e-03 | 9.57233337e-02 |
| PxP             | 1.27240399e+00 | 7.27129798e-03 | 6.68764207e-03 | 2.50945819e-04 | 2.86270310e-03 | 8.14306951e-02 |
| SOxSO           | 1.12705630e+00 | 6.63386864e-03 | 5.90923884e-03 | 2.15039386e-04 | 2.57217395e-03 | 6.60805660e-02 |
| SOxSO-PxP       | 2.59302907e-01 | 1.29066131e-03 | 1.61350202e-03 | 5.70365744e-05 | 5.42899390e-04 | 2.25531649e-02 |
| SOxP-PxP        | 1.34839739e-01 | 6.74460190e-04 | 8.72649106e-04 | 3.00865357e-05 | 2.80750585e-04 | 1.17659529e-02 |
| SOxP-SOxSO      | 1.26383866e-01 | 6.46344635e-04 | 7.89549942e-04 | 2.71976577e-05 | 2.66831051e-04 | 1.03998136e-02 |
| SOxSO+PxP-2SOxP | 3.55839364e-02 | 1.49604097e-04 | 2.58263533e-04 | 7.96732948e-06 | 6.95916555e-05 | 2.93349018e-03 |


** Comparison between different SO sensitivity mode
#+BEGIN_SRC ipython :session bcv :results raw drawer
  from getdist import loadMCSamples, plots, MCSamples

  def get_mean_diffs(path, cols):
      # Variable names
      renames = [r"$\Delta{}H_0~[\textrm{km/s}]$",
                 r"$\Delta{}n_\mathrm{s}$",
                 r"$\Delta\Omega_\mathrm{b}h^2$",
                 r"$\Delta\Omega_\mathrm{c}h^2$",
                 r"$\Delta\mathrm{A}_\mathrm{L}$"]
      # Load MC Samples
      tmp = loadMCSamples(path)

      # Get mean diffs as arrays
      mean_diffs = tmp.mean_diffs()

      # Keep only interesting columns i.e. cosmo; parameters
      mean_diffs = [mean_diffs[i] for i in cols]
      return MCSamples(samples=mean_diffs, names=renames, ignore_rows=0.3)


  output_path = r"/home/garrido/Workdir/CMB/analysis/beyondCV/output"

  # Planck 2018
  path = output_path + r"/COM_CosmoParams_fullGrid_R3.00/base_Alens/plikHM_TT_lowl_lowE/base_Alens_plikHM_TT_lowl_lowE"
  # cols = [22, 5, 6, 0, 1, 4]
  cols = [22, 6, 0, 1, 4]
  samples = [get_mean_diffs(path, cols)]

  # BeyondCV output
  mcmc_survey= ["SOxSO-PxP"]#, "SOxSO", "SOxSO-PxP", "SOxP-PxP", "SOxP-SOxSO"]
  cols = [0, 2, 3, 4, 5]
  for survey in mcmc_survey:
      path = output_path + r"/H0_old/results_{}_667_2/mcmc".format(survey)
      samples += [get_mean_diffs(path, cols)]

  for survey in mcmc_survey:
      path = output_path + r"/H0/results_{}_666_4/mcmc".format(survey)
      samples += [get_mean_diffs(path, cols)]

  g = plots.getSubplotPlotter()
  g.settings.lineM = ["--gray", "-C2", "--C2"]
  g.triangle_plot(samples, legend_labels=[])
  g.add_legend(["Planck 2018", r"{} ($\ell\in[2;3000]$)".format(mcmc_survey[0]), r"{} ($\ell\in[50; 2000]$)".format(mcmc_survey[0])], colored_text=False, figure=True, align_right=True)
  #  g.export("triangle_plot.pdf")
#+END_SRC

#+RESULTS:
:results:
# Out[78]:
: <matplotlib.legend.Legend at 0x7f1a2fdcd828>
[[file:./obipy-resources/BrNUzq.png]]
:end:

#+BEGIN_SRC ipython :session bcv :results raw drawer
  import numpy as np
  from getdist import loadMCSamples

  # Variable names
  xlabels = [r"$H_0$",
             r"$n_\mathrm{s}$",
             r"$\Omega_\mathrm{b}h^2$",
             r"$\Omega_\mathrm{c}h^2$",
             r"$\mathrm{A}_\mathrm{L}$"]

  output_path = r"/home/garrido/Workdir/CMB/analysis/beyondCV/output"

  # Planck 2018
  path = output_path + r"/COM_CosmoParams_fullGrid_R3.00/base_Alens/plikHM_TT_lowl_lowE/base_Alens_plikHM_TT_lowl_lowE"
  cols = [22, 6, 0, 1, 4]
  planck2018 = np.array([loadMCSamples(path).getVars()[i] for i in cols])

  # BeyondCV output
  surveys = ["PxP", "SOxSO", "SOxSO-PxP", "SOxP-PxP", "SOxP-SOxSO"]
  x = np.arange(len(xlabels))
  for s, survey in enumerate(surveys):
      path = output_path + r"/H0/results_{}_666_2/mcmc".format(survey)
      a = np.array([loadMCSamples(path, settings={"ignore_rows": 0.3}).getVars()[i] for i in [0, 2, 3, 4, 5]])
      if s == 0:
          pxp = planck2018 #a
      y = np.sqrt(pxp/a)
      plt.plot(x, y, "o", label=survey, color="C{}".format(s))
      # plt.axhline(np.mean(y), color="C{}".format(s), ls="--", lw=1)

  plt.xticks(x, xlabels)
  plt.ylabel(r"$\sigma{\rm(Planck~2018)}/\sigma{\rm(residuals)}$")
  plt.ylim(0,15)
  leg = plt.legend(loc="upper left", bbox_to_anchor=(1,1))
  for i, text in enumerate(leg.get_texts()):
      text.set_color("C{}".format(i))
#+END_SRC

#+RESULTS:
:results:
# Out[80]:
[[file:./obipy-resources/wAYAmu.png]]
:end:
